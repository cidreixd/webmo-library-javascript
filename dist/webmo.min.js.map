{"version":3,"sources":["webpack:///webmo.min.js","webpack:///webpack/bootstrap e36868dbfb8fc8baa2e0","webpack:///./index.js","webpack:///./lib/http.js","webpack:///./~/qwest/src/qwest.js","webpack:///./~/pinkyswear/pinkyswear.js","webpack:///(webpack)/buildin/module.js","webpack:///./~/timers-browserify/main.js","webpack:///./~/process/browser.js","webpack:///./~/jquery-param/jquery-param.js","webpack:///./lib/ws.js","webpack:///./~/eventemitter2/lib/eventemitter2.js","webpack:///./~/q/q.js"],"names":["Webmo","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","http","ws","qwest","host","this","base","_stepAngle","prototype","getStatus","get","rotate","speed","post","rotateTo","position","absRange","args","degree","absolute","rotateBy","rotateToHome","stop","smooth","lock","stopHard","stopSoft","lockHard","lockSoft","resetHome","angleToStep","angle","stepToAngle","step","getSpeedPerSecondByStep","Math","pow","getSpeedPerSecondByAngle","global","window","pinkyswear","jparam","defaultXdrResponseType","defaultDataType","limit","requests","request_stack","getXHR","XMLHttpRequest","ActiveXObject","xhr2","responseType","method","url","data","options","before","toUpperCase","nativeResponseParsing","crossOrigin","xhr","xdr","timeoutInterval","aborted","attempts","headers","mimeTypes","text","xml","json","accept","i","j","serialized","response","sending","delayed","timeout_start","promise","pinky","abort","send","push","Date","getTime","XDomainRequest","open","async","user","password","withCredentials","setRequestHeader","e","onload","handleResponse","onerror","handleError","onreadystatechange","readyState","overrideMimeType","onprogress","ontimeout","setTimeout","timeout","Error","length","shift","frame","document","createElement","style","display","body","appendChild","contentDocument","write","close","removeChild","ct","getResponseHeader","indexOf","responseText","JSON","parse","eval","DOMParser","parseFromString","loadXML","undefined","documentElement","getElementsByTagName","test","status","statusText","cache","dataType","toLowerCase","parseInt","match","location","ArrayBuffer","Blob","Document","FormData","stringify","format","p1","p2","replace","Accept","getNewPromise","q","promises","loading","values","createMethod","then","arguments","put","f","map","type","prop","apply","delete","by","setDefaultXdrResponseType","setDefaultDataType","getOpenRequests","setImmediate","process","target","isFunction","isObject","defer","callback","undef","pinkySwear","extend","state","deferred","set","newState","newValues","onFulfilled","onRejected","promise2","callCallbacks","resolve","x","cbCalled","TypeError","value","webpackPolyfill","deprecate","paths","children","clearImmediate","Timeout","clearFn","_id","_clearFn","nextTick","Function","slice","Array","immediateIds","nextImmediateId","clearTimeout","setInterval","clearInterval","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","fn","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","len","run","Item","fun","array","noop","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","param","a","add","s","k","v","encodeURIComponent","buildParams","prefix","obj","key","Object","toString","hasOwnProperty","join","EventEmitter","EventEmitter2","Q","stepDegree","onmessage","_ws","WebSocket","_ev","onopen","bind","onclose","console","log","packed","option","Promise","reject","msg","func","diff","unlock","tick","timeMs","degreeToStep","stepToDegree","getSpeedPerSecondByDegree","init","_events","_conf","configure","conf","delimiter","maxListeners","wildcard","newListener","listenerTree","searchListenerTree","handlers","tree","leaf","branch","xTree","xxTree","isolatedBranch","endReached","listeners","typeLength","currentType","nextType","_listeners","**","growListenerTree","listener","split","isArray","warned","defaultMaxListeners","error","trace","setMaxListeners","n","event","many","ttl","self","_origin","_all","l","handler","ns","emitAsync","all","onAny","recursivelyGarbageCollect","root","keys","leafs","iLeaf","splice","offAny","fns","listenersAny","definition","bootstrap","uncurryThis","isStopIteration","exception","object_toString","QReturnValue","makeStackTraceLong","hasStacks","stack","STACK_JUMP_SEPARATOR","stacks","source","unshift","concatedStacks","filterStackString","stackString","lines","desiredLines","line","isInternalFrame","isNodeFrame","stackLine","getFileNameAndLineNumber","attempt1","exec","Number","attempt2","attempt3","fileNameAndLineNumber","fileName","lineNumber","qFileName","qStartingLine","qEndingLine","captureLine","firstLine","alternative","warn","isPromiseAlike","coerce","fulfill","become","newPromise","resolvedPromise","array_reduce","messages","message","promiseDispatch","progressListeners","object_create","op","operands","array_slice","valueOf","nearerValue","nearer","isPromise","inspect","longStackSupport","substring","reason","notify","progress","progressListener","resolver","race","answerPs","descriptor","fallback","result","inspected","when","fulfilled","rejected","progressed","object","isPending","isFulfilled","isRejected","resetUnhandledRejections","unhandledReasons","unhandledRejections","trackUnhandledRejections","trackRejection","runAfter","array_indexOf","reportedUnhandledRejections","untrackRejection","at","atReport","rejection","rhs","thisp","object_keys","master","isDef","dispatch","spread","makeGenerator","continuer","verb","arg","StopIteration","generator","done","errback","spawn","_return","promised","pendingCount","index","snapshot","any","prev","current","onProgress","allResolved","array_map","allSettled","nodeify","nodeback","flush","task","domain","head","next","enter","runSingle","laterQueue","pop","flushing","isNodeJS","exit","tail","requestTick","MessageChannel","channel","port1","requestPortTick","port2","postMessage","reduce","basis","collect","create","Type","object_hasOwnProperty","ReturnValue","Q_DEBUG","makeNodeResolver","passByCopy","y","that","makePromise","_fulfilled","_rejected","newException","_progressed","newValue","threw","tap","fcall","thenResolve","thenReject","getUnhandledReasons","stopUnhandledRejectionTracking","del","mapply","mcall","invoke","fapply","fbind","regardless","fail","fin","onUnhandledError","ms","timeoutId","code","delay","nfapply","nodeArgs","nfcall","nfbind","denodeify","baseArgs","nbind","bound","nmapply","npost","nsend","nmcall","ninvoke","noConflict"],"mappings":"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","file":"webmo.min.js","sourcesContent":["var Webmo =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = {\n\t  http: __webpack_require__(1),\n\t  ws: __webpack_require__(8)\n\t}\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar qwest = __webpack_require__(2)\n\t\n\tvar Webmo = function Webmo (host) {\n\t  this.base = '//' + (host || 'webmo.local')\n\t  this.base += '/api'\n\t  qwest.base = this.base\n\t\n\t  this._stepAngle = 1.8\n\t}\n\t\n\tWebmo.prototype.getStatus = function getStatus () {\n\t  return qwest.get('/status')\n\t}\n\t\n\t/**\n\t * Webmo\n\t * PromiseWeb\n\t *\n\t * @param {number} [speed] - (/)\n\t * @returns {Promise}\n\t */\n\tWebmo.prototype.rotate = function rotate (speed) {\n\t  return qwest.post('/rotate/forever', {speed: speed})\n\t}\n\t\n\tWebmo.prototype.rotateTo = function rotateTo (position, absRange, speed) {\n\t  var args = {\n\t    degree: position,\n\t    absRange: absRange,\n\t    speed: speed,\n\t    absolute: true\n\t  }\n\t\n\t  return qwest.post('/rotate', args)\n\t}\n\t\n\t/**\n\t * Webmo\n\t * : \n\t * : \n\t * PromiseWeb\n\t * \n\t *\n\t * @param {number} [degree] - ()\n\t * @param {number} [speed] - (/)\n\t * @returns {Promise}\n\t */\n\tWebmo.prototype.rotateBy = function rotateBy (degree, speed) {\n\t  var args = {\n\t    degree: degree,\n\t    speed: speed\n\t  }\n\t\n\t  return qwest.post('/rotate', args)\n\t}\n\t\n\t// XXX: Later\n\tWebmo.prototype.rotateToHome = function rotateToHome () {\n\t  return qwest.post('/rotate/home', {})\n\t}\n\t\n\t/**\n\t * Webmo\n\t *\n\t * @param {boolean} [smooth] - \n\t * @param {boolean} [lock] - \n\t * @returns {Promise}\n\t */\n\tWebmo.prototype.stop = function stop (smooth, lock) {\n\t  smooth = smooth || false\n\t  lock = lock || false\n\t  return qwest.post('/stop', {smooth: smooth, lock: lock})\n\t}\n\t\n\t/**\n\t * Webmo\n\t * \n\t *\n\t * @returns {Promise}\n\t */\n\tWebmo.prototype.stopHard = function stopHard () {\n\t  return qwest.post('/stop', {smooth: false})\n\t}\n\t\n\t/**\n\t * Webmo\n\t * \n\t *\n\t * @returns {Promise}\n\t */\n\tWebmo.prototype.stopSoft = function stopSoft () {\n\t  return qwest.post('/stop', {smooth: true})\n\t}\n\t\n\t/**\n\t * Webmo\n\t * \n\t *\n\t * @returns {Promise}\n\t */\n\tWebmo.prototype.lockHard = function () {\n\t  return qwest.post('/stop', {smooth: false})\n\t}\n\t\n\t/**\n\t * Webmo\n\t * \n\t *\n\t * @returns {Promise}\n\t */\n\tWebmo.prototype.lockSoft = function () {\n\t  return qwest.post('/stop', {smooth: true})\n\t}\n\t\n\t// XXX: Later\n\tWebmo.prototype.resetHome = function resetHome () {\n\t  return qwest.post('/home/reset', {})\n\t}\n\t\n\t/**\n\t * ()\n\t *\n\t * @param {Number} [angle] - \n\t * @returns {Number} - \n\t */\n\tWebmo.prototype.angleToStep = function angleToStep (angle) {\n\t  return angle / this._stepAngle\n\t}\n\t\n\t/**\n\t * \n\t *\n\t * @param {Number} [step] - \n\t * @returns {Number} - \n\t */\n\tWebmo.prototype.stepToAngle = function stepToAngle (step) {\n\t  return step * this._stepAngle / 128 // XXX: microstep must be supplied\n\t}\n\t\n\t\n\t// XXX: Later\n\tWebmo.prototype.getSpeedPerSecondByStep = function getSpeedPerSecondByStep (step) {\n\t  return Math.pow(2, 28) * step / Math.pow(10, 9) * 250\n\t}\n\t\n\t// XXX: Later\n\tWebmo.prototype.getSpeedPerSecondByAngle = function getSpeedPerSecondByAngle (angle) {\n\t  return this.getSpeedPerSecondByStep(this.angleToStep(angle))\n\t}\n\t\n\tmodule.exports = Webmo\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*! qwest 4.1.1 (https://github.com/pyrsmk/qwest) */\r\n\t\r\n\tmodule.exports = function() {\r\n\t\r\n\t\tvar global = window || this,\r\n\t\t\tpinkyswear = __webpack_require__(3),\r\n\t\t\tjparam = __webpack_require__(7),\r\n\t\t\t// Default response type for XDR in auto mode\r\n\t\t\tdefaultXdrResponseType = 'json',\r\n\t\t\t// Default data type\r\n\t\t\tdefaultDataType = 'post',\r\n\t\t\t// Variables for limit mechanism\r\n\t\t\tlimit = null,\r\n\t\t\trequests = 0,\r\n\t\t\trequest_stack = [],\r\n\t\t\t// Get XMLHttpRequest object\r\n\t\t\tgetXHR = global.XMLHttpRequest? function(){\r\n\t\t\t\treturn new global.XMLHttpRequest();\r\n\t\t\t}: function(){\r\n\t\t\t\treturn new ActiveXObject('Microsoft.XMLHTTP');\r\n\t\t\t},\r\n\t\t\t// Guess XHR version\r\n\t\t\txhr2 = (getXHR().responseType===''),\r\n\t\r\n\t\t// Core function\r\n\t\tqwest = function(method, url, data, options, before) {\r\n\t\t\t// Format\r\n\t\t\tmethod = method.toUpperCase();\r\n\t\t\tdata = data || null;\r\n\t\t\toptions = options || {};\r\n\t\r\n\t\t\t// Define variables\r\n\t\t\tvar nativeResponseParsing = false,\r\n\t\t\t\tcrossOrigin,\r\n\t\t\t\txhr,\r\n\t\t\t\txdr = false,\r\n\t\t\t\ttimeoutInterval,\r\n\t\t\t\taborted = false,\r\n\t\t\t\tattempts = 0,\r\n\t\t\t\theaders = {},\r\n\t\t\t\tmimeTypes = {\r\n\t\t\t\t\ttext: '*/*',\r\n\t\t\t\t\txml: 'text/xml',\r\n\t\t\t\t\tjson: 'application/json',\r\n\t\t\t\t\tpost: 'application/x-www-form-urlencoded'\r\n\t\t\t\t},\r\n\t\t\t\taccept = {\r\n\t\t\t\t\ttext: '*/*',\r\n\t\t\t\t\txml: 'application/xml; q=1.0, text/xml; q=0.8, */*; q=0.1',\r\n\t\t\t\t\tjson: 'application/json; q=1.0, text/*; q=0.8, */*; q=0.1'\r\n\t\t\t\t},\r\n\t\t\t\ti, j,\r\n\t\t\t\tserialized,\r\n\t\t\t\tresponse,\r\n\t\t\t\tsending = false,\r\n\t\t\t\tdelayed = false,\r\n\t\t\t\ttimeout_start,\r\n\t\r\n\t\t\t// Create the promise\r\n\t\t\tpromise = pinkyswear(function(pinky) {\r\n\t\t\t\tpinky.abort = function() {\r\n\t\t\t\t\tif(xhr) {\r\n\t\t\t\t\t\txhr.abort();\r\n\t\t\t\t\t\t--requests;\r\n\t\t\t\t\t\taborted = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tpinky.send = function() {\r\n\t\t\t\t\t// Prevent further send() calls\r\n\t\t\t\t\tif(sending) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Reached request limit, get out!\r\n\t\t\t\t\tif(requests == limit) {\r\n\t\t\t\t\t\trequest_stack.push(pinky);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t++requests;\r\n\t\t\t\t\tsending = true;\r\n\t\t\t\t\t// Start the chrono\r\n\t\t\t\t\ttimeout_start = new Date().getTime();\r\n\t\t\t\t\t// Get XHR object\r\n\t\t\t\t\txhr = getXHR();\r\n\t\t\t\t\tif(crossOrigin) {\r\n\t\t\t\t\t\tif(!('withCredentials' in xhr) && global.XDomainRequest) {\r\n\t\t\t\t\t\t\txhr = new XDomainRequest(); // CORS with IE8/9\r\n\t\t\t\t\t\t\txdr = true;\r\n\t\t\t\t\t\t\tif(method!='GET' && method!='POST') {\r\n\t\t\t\t\t\t\t\tmethod = 'POST';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Open connection\r\n\t\t\t\t\tif(xdr) {\r\n\t\t\t\t\t\txhr.open(method, url);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\txhr.open(method, url, options.async, options.user, options.password);\r\n\t\t\t\t\t\tif(xhr2 && options.async) {\r\n\t\t\t\t\t\t\txhr.withCredentials = options.withCredentials;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Set headers\r\n\t\t\t\t\tif(!xdr) {\r\n\t\t\t\t\t\tfor(var i in headers) {\r\n\t\t\t\t\t\t\tif(headers[i]) {\r\n\t\t\t\t\t\t\t\txhr.setRequestHeader(i, headers[i]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Verify if the response type is supported by the current browser\r\n\t\t\t\t\tif(xhr2 && options.responseType != 'document' && options.responseType!='auto') { // Don't verify for 'document' since we're using an internal routine\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\txhr.responseType = options.responseType;\r\n\t\t\t\t\t\t\tnativeResponseParsing = (xhr.responseType==options.responseType);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch(e){}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Plug response handler\r\n\t\t\t\t\tif(xhr2 || xdr) {\r\n\t\t\t\t\t\txhr.onload = handleResponse;\r\n\t\t\t\t\t\txhr.onerror = handleError;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\txhr.onreadystatechange = function() {\r\n\t\t\t\t\t\t\tif(xhr.readyState == 4) {\r\n\t\t\t\t\t\t\t\thandleResponse();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Override mime type to ensure the response is well parsed\r\n\t\t\t\t\tif(options.responseType != 'auto' && 'overrideMimeType' in xhr) {\r\n\t\t\t\t\t\txhr.overrideMimeType(mimeTypes[options.responseType]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Run 'before' callback\r\n\t\t\t\t\tif(before) {\r\n\t\t\t\t\t\tbefore(xhr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Send request\r\n\t\t\t\t\tif(xdr) {\r\n\t\t\t\t\t\t// http://cypressnorth.com/programming/internet-explorer-aborting-ajax-requests-fixed/\r\n\t\t\t\t\t\txhr.onprogress = function(){};\r\n\t\t\t\t\t\txhr.ontimeout = function(){};\r\n\t\t\t\t\t\txhr.onerror = function(){};\r\n\t\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/XDomainRequest\r\n\t\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\t\txhr.send(method != 'GET'? data : null);\r\n\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\txhr.send(method != 'GET' ? data : null);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\treturn pinky;\r\n\t\t\t}),\r\n\t\r\n\t\t\t// Handle the response\r\n\t\t\thandleResponse = function() {\r\n\t\t\t\t// Prepare\r\n\t\t\t\tvar i, responseType;\r\n\t\t\t\t--requests;\r\n\t\t\t\tsending = false;\r\n\t\t\t\t// Verify timeout state\r\n\t\t\t\t// --- https://stackoverflow.com/questions/7287706/ie-9-javascript-error-c00c023f\r\n\t\t\t\tif(new Date().getTime()-timeout_start >= options.timeout) {\r\n\t\t\t\t\tif(!options.attempts || ++attempts!=options.attempts) {\r\n\t\t\t\t\t\tpromise.send();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpromise(false, [new Error('Timeout ('+url+')'), xhr, response]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t// Launch next stacked request\r\n\t\t\t\tif(request_stack.length) {\r\n\t\t\t\t\trequest_stack.shift().send();\r\n\t\t\t\t}\r\n\t\t\t\t// Handle response\r\n\t\t\t\ttry{\r\n\t\t\t\t\t// Process response\r\n\t\t\t\t\tif(nativeResponseParsing && 'response' in xhr && xhr.response!==null) {\r\n\t\t\t\t\t\tresponse = xhr.response;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if(options.responseType == 'document') {\r\n\t\t\t\t\t\tvar frame = document.createElement('iframe');\r\n\t\t\t\t\t\tframe.style.display = 'none';\r\n\t\t\t\t\t\tdocument.body.appendChild(frame);\r\n\t\t\t\t\t\tframe.contentDocument.open();\r\n\t\t\t\t\t\tframe.contentDocument.write(xhr.response);\r\n\t\t\t\t\t\tframe.contentDocument.close();\r\n\t\t\t\t\t\tresponse = frame.contentDocument;\r\n\t\t\t\t\t\tdocument.body.removeChild(frame);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\t// Guess response type\r\n\t\t\t\t\t\tresponseType = options.responseType;\r\n\t\t\t\t\t\tif(responseType == 'auto') {\r\n\t\t\t\t\t\t\tif(xdr) {\r\n\t\t\t\t\t\t\t\tresponseType = defaultXdrResponseType;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tvar ct = xhr.getResponseHeader('Content-Type') || '';\r\n\t\t\t\t\t\t\t\tif(ct.indexOf(mimeTypes.json)>-1) {\r\n\t\t\t\t\t\t\t\t\tresponseType = 'json';\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse if(ct.indexOf(mimeTypes.xml)>-1) {\r\n\t\t\t\t\t\t\t\t\tresponseType = 'xml';\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tresponseType = 'text';\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Handle response type\r\n\t\t\t\t\t\tswitch(responseType) {\r\n\t\t\t\t\t\t\tcase 'json':\r\n\t\t\t\t\t\t\t\tif(xhr.responseText.length) {\r\n\t\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\t\tif('JSON' in global) {\r\n\t\t\t\t\t\t\t\t\t\t\tresponse = JSON.parse(xhr.responseText);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\tresponse = eval('('+xhr.responseText+')');\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tcatch(e) {\r\n\t\t\t\t\t\t\t\t\t\tthrow \"Error while parsing JSON body : \"+e;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 'xml':\r\n\t\t\t\t\t\t\t\t// Based on jQuery's parseXML() function\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\t// Standard\r\n\t\t\t\t\t\t\t\t\tif(global.DOMParser) {\r\n\t\t\t\t\t\t\t\t\t\tresponse = (new DOMParser()).parseFromString(xhr.responseText,'text/xml');\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t// IE<9\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\tresponse = new ActiveXObject('Microsoft.XMLDOM');\r\n\t\t\t\t\t\t\t\t\t\tresponse.async = 'false';\r\n\t\t\t\t\t\t\t\t\t\tresponse.loadXML(xhr.responseText);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcatch(e) {\r\n\t\t\t\t\t\t\t\t\tresponse = undefined;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif(!response || !response.documentElement || response.getElementsByTagName('parsererror').length) {\r\n\t\t\t\t\t\t\t\t\tthrow 'Invalid XML';\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\tresponse = xhr.responseText;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Late status code verification to allow passing data when, per example, a 409 is returned\r\n\t\t\t\t\t// --- https://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\r\n\t\t\t\t\tif('status' in xhr && !/^2|1223/.test(xhr.status)) {\r\n\t\t\t\t\t\tthrow xhr.status+' ('+xhr.statusText+')';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Fulfilled\r\n\t\t\t\t\tpromise(true, [xhr, response]);\r\n\t\t\t\t}\r\n\t\t\t\tcatch(e) {\r\n\t\t\t\t\t// Rejected\r\n\t\t\t\t\tpromise(false, [e, xhr, response]);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\t// Handle errors\r\n\t\t\thandleError = function(e) {\r\n\t\t\t\t--requests;\r\n\t\t\t\tpromise(false, [new Error('Connection aborted'), xhr, null]);\r\n\t\t\t};\r\n\t\r\n\t\t\t// Normalize options\r\n\t\t\toptions.async = 'async' in options?!!options.async:true;\r\n\t\t\toptions.cache = 'cache' in options?!!options.cache:false;\r\n\t\t\toptions.dataType = 'dataType' in options?options.dataType.toLowerCase():defaultDataType;\r\n\t\t\toptions.responseType = 'responseType' in options?options.responseType.toLowerCase():'auto';\r\n\t\t\toptions.user = options.user || '';\r\n\t\t\toptions.password = options.password || '';\r\n\t\t\toptions.withCredentials = !!options.withCredentials;\r\n\t\t\toptions.timeout = 'timeout' in options?parseInt(options.timeout,10):30000;\r\n\t\t\toptions.attempts = 'attempts' in options?parseInt(options.attempts,10):1;\r\n\t\r\n\t\t\t// Guess if we're dealing with a cross-origin request\r\n\t\t\ti = url.match(/\\/\\/(.+?)\\//);\r\n\t\t\tcrossOrigin = i && (i[1]?i[1]!=location.host:false);\r\n\t\r\n\t\t\t// Prepare data\r\n\t\t\tif('ArrayBuffer' in global && data instanceof ArrayBuffer) {\r\n\t\t\t\toptions.dataType = 'arraybuffer';\r\n\t\t\t}\r\n\t\t\telse if('Blob' in global && data instanceof Blob) {\r\n\t\t\t\toptions.dataType = 'blob';\r\n\t\t\t}\r\n\t\t\telse if('Document' in global && data instanceof Document) {\r\n\t\t\t\toptions.dataType = 'document';\r\n\t\t\t}\r\n\t\t\telse if('FormData' in global && data instanceof FormData) {\r\n\t\t\t\toptions.dataType = 'formdata';\r\n\t\t\t}\r\n\t\t\tswitch(options.dataType) {\r\n\t\t\t\tcase 'json':\r\n\t\t\t\t\tdata = (data !== null ? JSON.stringify(data) : data);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'post':\r\n\t\t\t\t\tdata = jparam(data);\r\n\t\t\t}\r\n\t\r\n\t\t\t// Prepare headers\r\n\t\t\tif(options.headers) {\r\n\t\t\t\tvar format = function(match,p1,p2) {\r\n\t\t\t\t\treturn p1 + p2.toUpperCase();\r\n\t\t\t\t};\r\n\t\t\t\tfor(i in options.headers) {\r\n\t\t\t\t\theaders[i.replace(/(^|-)([^-])/g,format)] = options.headers[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(!('Content-Type' in headers) && method!='GET') {\r\n\t\t\t\tif(options.dataType in mimeTypes) {\r\n\t\t\t\t\tif(mimeTypes[options.dataType]) {\r\n\t\t\t\t\t\theaders['Content-Type'] = mimeTypes[options.dataType];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(!headers.Accept) {\r\n\t\t\t\theaders.Accept = (options.responseType in accept)?accept[options.responseType]:'*/*';\r\n\t\t\t}\r\n\t\t\tif(!crossOrigin && !('X-Requested-With' in headers)) { // (that header breaks in legacy browsers with CORS)\r\n\t\t\t\theaders['X-Requested-With'] = 'XMLHttpRequest';\r\n\t\t\t}\r\n\t\t\tif(!options.cache && !('Cache-Control' in headers)) {\r\n\t\t\t\theaders['Cache-Control'] = 'no-cache';\r\n\t\t\t}\r\n\t\r\n\t\t\t// Prepare URL\r\n\t\t\tif(method == 'GET' && data && typeof data == 'string') {\r\n\t\t\t\turl += (/\\?/.test(url)?'&':'?') + data;\r\n\t\t\t}\r\n\t\r\n\t\t\t// Start the request\r\n\t\t\tif(options.async) {\r\n\t\t\t\tpromise.send();\r\n\t\t\t}\r\n\t\r\n\t\t\t// Return promise\r\n\t\t\treturn promise;\r\n\t\r\n\t\t};\r\n\t\t\r\n\t\t// Define external qwest object\r\n\t\tvar getNewPromise = function(q) {\r\n\t\t\t\t// Prepare\r\n\t\t\t\tvar promises = [],\r\n\t\t\t\t\tloading = 0,\r\n\t\t\t\t\tvalues = [];\r\n\t\t\t\t// Create a new promise to handle all requests\r\n\t\t\t\treturn pinkyswear(function(pinky) {\r\n\t\t\t\t\t// Basic request method\r\n\t\t\t\t\tvar createMethod = function(method) {\r\n\t\t\t\t\t\treturn function(url, data, options, before) {\r\n\t\t\t\t\t\t\t++loading;\r\n\t\t\t\t\t\t\tpromises.push(qwest(method, pinky.base + url, data, options, before).then(function(xhr, response) {\r\n\t\t\t\t\t\t\t\tvalues.push(arguments);\r\n\t\t\t\t\t\t\t\tif(!--loading) {\r\n\t\t\t\t\t\t\t\t\tpinky(true, values.length == 1 ? values[0] : [values]);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}, function() {\r\n\t\t\t\t\t\t\t\tpinky(false, arguments);\r\n\t\t\t\t\t\t\t}));\r\n\t\t\t\t\t\t\treturn pinky;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t};\r\n\t\t\t\t\t// Define external API\r\n\t\t\t\t\tpinky.get = createMethod('GET');\r\n\t\t\t\t\tpinky.post = createMethod('POST');\r\n\t\t\t\t\tpinky.put = createMethod('PUT');\r\n\t\t\t\t\tpinky['delete'] = createMethod('DELETE');\r\n\t\t\t\t\tpinky['catch'] = function(f) {\r\n\t\t\t\t\t\treturn pinky.then(null, f);\r\n\t\t\t\t\t};\r\n\t\t\t\t\tpinky.map = function(type, url, data, options, before) {\r\n\t\t\t\t\t\treturn createMethod(type.toUpperCase()).call(this, url, data, options, before);\r\n\t\t\t\t\t};\r\n\t\t\t\t\tfor(var prop in q) {\r\n\t\t\t\t\t\tif(!(prop in pinky)) {\r\n\t\t\t\t\t\t\tpinky[prop] = q[prop];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpinky.send = function() {\r\n\t\t\t\t\t\tfor(var i=0, j=promises.length; i<j; ++i) {\r\n\t\t\t\t\t\t\tpromises[i].send();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn pinky;\r\n\t\t\t\t\t};\r\n\t\t\t\t\tpinky.abort = function() {\r\n\t\t\t\t\t\tfor(var i=0, j=promises.length; i<j; ++i) {\r\n\t\t\t\t\t\t\tpromises[i].abort();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn pinky;\r\n\t\t\t\t\t};\r\n\t\t\t\t\treturn pinky;\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tq = {\r\n\t\t\t\tbase: '',\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\treturn getNewPromise(q).get.apply(this, arguments);\r\n\t\t\t\t},\r\n\t\t\t\tpost: function() {\r\n\t\t\t\t\treturn getNewPromise(q).post.apply(this, arguments);\r\n\t\t\t\t},\r\n\t\t\t\tput: function() {\r\n\t\t\t\t\treturn getNewPromise(q).put.apply(this, arguments);\r\n\t\t\t\t},\r\n\t\t\t\t'delete': function() {\r\n\t\t\t\t\treturn getNewPromise(q)['delete'].apply(this, arguments);\r\n\t\t\t\t},\r\n\t\t\t\tmap: function() {\r\n\t\t\t\t\treturn getNewPromise(q).map.apply(this, arguments);\r\n\t\t\t\t},\r\n\t\t\t\txhr2: xhr2,\r\n\t\t\t\tlimit: function(by) {\r\n\t\t\t\t\tlimit = by;\r\n\t\t\t\t\treturn q;\r\n\t\t\t\t},\r\n\t\t\t\tsetDefaultXdrResponseType: function(type) {\r\n\t\t\t\t\tdefaultXdrResponseType = type.toLowerCase();\r\n\t\t\t\t\treturn q;\r\n\t\t\t\t},\r\n\t\t\t\tsetDefaultDataType: function(type) {\r\n\t\t\t\t\tdefaultDataType = type.toLowerCase();\r\n\t\t\t\t\treturn q;\r\n\t\t\t\t},\r\n\t\t\t\tgetOpenRequests: function() {\r\n\t\t\t\t\treturn requests;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\r\n\t\treturn q;\r\n\t\r\n\t}();\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module, setImmediate, process) {/*\n\t * PinkySwear.js 2.2.2 - Minimalistic implementation of the Promises/A+ spec\n\t * \n\t * Public Domain. Use, modify and distribute it any way you like. No attribution required.\n\t *\n\t * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\t *\n\t * PinkySwear is a very small implementation of the Promises/A+ specification. After compilation with the\n\t * Google Closure Compiler and gzipping it weighs less than 500 bytes. It is based on the implementation for \n\t * Minified.js and should be perfect for embedding. \n\t *\n\t *\n\t * PinkySwear has just three functions.\n\t *\n\t * To create a new promise in pending state, call pinkySwear():\n\t *         var promise = pinkySwear();\n\t *\n\t * The returned object has a Promises/A+ compatible then() implementation:\n\t *          promise.then(function(value) { alert(\"Success!\"); }, function(value) { alert(\"Failure!\"); });\n\t *\n\t *\n\t * The promise returned by pinkySwear() is a function. To fulfill the promise, call the function with true as first argument and\n\t * an optional array of values to pass to the then() handler. By putting more than one value in the array, you can pass more than one\n\t * value to the then() handlers. Here an example to fulfill a promsise, this time with only one argument: \n\t *         promise(true, [42]);\n\t *\n\t * When the promise has been rejected, call it with false. Again, there may be more than one argument for the then() handler:\n\t *         promise(true, [6, 6, 6]);\n\t *         \n\t * You can obtain the promise's current state by calling the function without arguments. It will be true if fulfilled,\n\t * false if rejected, and otherwise undefined.\n\t * \t\t   var state = promise(); \n\t * \n\t * https://github.com/timjansen/PinkySwear.js\n\t */\n\t(function(target) {\n\t\tvar undef;\n\t\n\t\tfunction isFunction(f) {\n\t\t\treturn typeof f == 'function';\n\t\t}\n\t\tfunction isObject(f) {\n\t\t\treturn typeof f == 'object';\n\t\t}\n\t\tfunction defer(callback) {\n\t\t\tif (typeof setImmediate != 'undefined')\n\t\t\t\tsetImmediate(callback);\n\t\t\telse if (typeof process != 'undefined' && process['nextTick'])\n\t\t\t\tprocess['nextTick'](callback);\n\t\t\telse\n\t\t\t\tsetTimeout(callback, 0);\n\t\t}\n\t\n\t\ttarget[0][target[1]] = function pinkySwear(extend) {\n\t\t\tvar state;           // undefined/null = pending, true = fulfilled, false = rejected\n\t\t\tvar values = [];     // an array of values as arguments for the then() handlers\n\t\t\tvar deferred = [];   // functions to call when set() is invoked\n\t\n\t\t\tvar set = function(newState, newValues) {\n\t\t\t\tif (state == null && newState != null) {\n\t\t\t\t\tstate = newState;\n\t\t\t\t\tvalues = newValues;\n\t\t\t\t\tif (deferred.length)\n\t\t\t\t\t\tdefer(function() {\n\t\t\t\t\t\t\tfor (var i = 0; i < deferred.length; i++)\n\t\t\t\t\t\t\t\tdeferred[i]();\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn state;\n\t\t\t};\n\t\n\t\t\tset['then'] = function (onFulfilled, onRejected) {\n\t\t\t\tvar promise2 = pinkySwear(extend);\n\t\t\t\tvar callCallbacks = function() {\n\t\t    \t\ttry {\n\t\t    \t\t\tvar f = (state ? onFulfilled : onRejected);\n\t\t    \t\t\tif (isFunction(f)) {\n\t\t\t   \t\t\t\tfunction resolve(x) {\n\t\t\t\t\t\t\t    var then, cbCalled = 0;\n\t\t\t   \t\t\t\t\ttry {\n\t\t\t\t\t   \t\t\t\tif (x && (isObject(x) || isFunction(x)) && isFunction(then = x['then'])) {\n\t\t\t\t\t\t\t\t\t\t\tif (x === promise2)\n\t\t\t\t\t\t\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t\t\t\t\t\t\tthen['call'](x,\n\t\t\t\t\t\t\t\t\t\t\t\tfunction() { if (!cbCalled++) resolve.apply(undef,arguments); } ,\n\t\t\t\t\t\t\t\t\t\t\t\tfunction(value){ if (!cbCalled++) promise2(false,[value]);});\n\t\t\t\t\t   \t\t\t\t}\n\t\t\t\t\t   \t\t\t\telse\n\t\t\t\t\t   \t\t\t\t\tpromise2(true, arguments);\n\t\t\t   \t\t\t\t\t}\n\t\t\t   \t\t\t\t\tcatch(e) {\n\t\t\t   \t\t\t\t\t\tif (!cbCalled++)\n\t\t\t   \t\t\t\t\t\t\tpromise2(false, [e]);\n\t\t\t   \t\t\t\t\t}\n\t\t\t   \t\t\t\t}\n\t\t\t   \t\t\t\tresolve(f.apply(undef, values || []));\n\t\t\t   \t\t\t}\n\t\t\t   \t\t\telse\n\t\t\t   \t\t\t\tpromise2(state, values);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\tpromise2(false, [e]);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (state != null)\n\t\t\t\t\tdefer(callCallbacks);\n\t\t\t\telse\n\t\t\t\t\tdeferred.push(callCallbacks);\n\t\t\t\treturn promise2;\n\t\t\t};\n\t        if(extend){\n\t            set = extend(set);\n\t        }\n\t\t\treturn set;\n\t\t};\n\t})( false ? [window, 'pinkySwear'] : [module, 'exports']);\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module), __webpack_require__(5).setImmediate, __webpack_require__(6)))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(6).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate, __webpack_require__(5).clearImmediate))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n\t * @preserve jquery-param (c) 2015 KNOWLEDGECODE | MIT\n\t */\n\t/*global define */\n\t(function (global) {\n\t    'use strict';\n\t\n\t    var param = function (a) {\n\t        var add = function (s, k, v) {\n\t            v = typeof v === 'function' ? v() : v === null ? '' : v === undefined ? '' : v;\n\t            s[s.length] = encodeURIComponent(k) + '=' + encodeURIComponent(v);\n\t        }, buildParams = function (prefix, obj, s) {\n\t            var i, len, key;\n\t\n\t            if (Object.prototype.toString.call(obj) === '[object Array]') {\n\t                for (i = 0, len = obj.length; i < len; i++) {\n\t                    buildParams(prefix + '[' + (typeof obj[i] === 'object' ? i : '') + ']', obj[i], s);\n\t                }\n\t            } else if (obj && obj.toString() === '[object Object]') {\n\t                for (key in obj) {\n\t                    if (obj.hasOwnProperty(key)) {\n\t                        if (prefix) {\n\t                            buildParams(prefix + '[' + key + ']', obj[key], s, add);\n\t                        } else {\n\t                            buildParams(key, obj[key], s, add);\n\t                        }\n\t                    }\n\t                }\n\t            } else if (prefix) {\n\t                add(s, prefix, obj);\n\t            } else {\n\t                for (key in obj) {\n\t                    add(s, key, obj[key]);\n\t                }\n\t            }\n\t            return s;\n\t        };\n\t        return buildParams('', a, []).join('&').replace(/%20/g, '+');\n\t    };\n\t\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        module.exports = param;\n\t    } else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t            return param;\n\t        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else {\n\t        global.param = param;\n\t    }\n\t\n\t}(this));\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global WebSocket */\n\tvar EventEmitter = __webpack_require__(9).EventEmitter2\n\tvar Q = __webpack_require__(10)\n\t\n\tvar Webmo = function Webmo (host) {\n\t  host = host || 'webmo.local'\n\t\n\t  this.host = host\n\t  this.stepDegree = 1.8\n\t  this.onmessage = null\n\t  this._ws = new WebSocket('ws://' + host + ':8080/')\n\t  this._ev = new EventEmitter()\n\t\n\t  this._ws.onopen = function (e) {\n\t    if (typeof (this.onopen) === 'function') {\n\t      this.onopen(e)\n\t    }\n\t    this._ev.emit('open')\n\t  }.bind(this)\n\t\n\t  this._ws.onmessage = function (e) {\n\t    var json = JSON.parse(e.data)\n\t\n\t    if (typeof (this.onmessage) === 'function') {\n\t      this.onmessage(json)\n\t    }\n\t    this._ev.emit(json.type, json)\n\t  }.bind(this)\n\t\n\t  this._ws.onclose = function (e) {\n\t    if (typeof (this.onclose) === 'function') {\n\t      this.onclose()\n\t    }\n\t\n\t    console.log('closed', e)\n\t  }.bind(this)\n\t\n\t  this._ws.onerror = function (e) {\n\t    if (typeof (this.onerror) === 'function') {\n\t      this.onerror()\n\t    }\n\t    console.log('error!', e)\n\t  }.bind(this)\n\t}\n\t\n\tWebmo.prototype.getStatus = function getStatus () {\n\t  var packed = JSON.stringify({type: 'status'})\n\t  this._ws.send(packed)\n\t}\n\t\n\t//\n\t// rotate\n\t//\n\tWebmo.prototype.rotate = function rotate (speed, option) {\n\t  if (typeof speed === 'object') {\n\t    option = speed\n\t    speed = undefined\n\t  }\n\t\n\t  var packed = JSON.stringify({type: 'rotate', speed: speed})\n\t  this._ws.send(packed)\n\t}\n\t\n\tWebmo.prototype.rotateTo = function rotateTo (target, absRange, speed) {\n\t  var packed = JSON.stringify({type: 'rotateTo', target: target, absRange: absRange, speed: speed})\n\t  this._ws.send(packed)\n\t\n\t  // XXX: reject\n\t  return Q.Promise(function (resolve, reject) {\n\t    this._ev.on('notice', function (data) {\n\t      if (data.msg === 'done' && data.func === 'rotateTo') {\n\t        resolve(data)\n\t      }\n\t    })\n\t  }.bind(this))\n\t}\n\t\n\tWebmo.prototype.rotateBy = function rotateBy (diff, speed) {\n\t  var packed = JSON.stringify({type: 'rotateBy', diff: diff, speed: speed})\n\t  this._ws.send(packed)\n\t\n\t  // XXX: reject\n\t  return Q.Promise(function (resolve, reject) {\n\t    this._ev.on('notice', function (data) {\n\t      if (data.msg === 'done' && data.func === 'rotateBy') {\n\t        resolve(data)\n\t      }\n\t    })\n\t  }.bind(this))\n\t}\n\t\n\tWebmo.prototype.rotateToHome = function rotateToHome () {\n\t  console.log('not impl')\n\t}\n\t\n\t//\n\t// Stop\n\t//\n\tWebmo.prototype.stopHard = function stopHard () {\n\t  return this.stop(true, false)\n\t}\n\t\n\tWebmo.prototype.stopSoft = function stopSoft () {\n\t  return this.stop(false, false)\n\t}\n\t\n\tWebmo.prototype.stop = function stop (smooth, lock) {\n\t  var packed = JSON.stringify({type: 'stop', smooth: smooth, lock: lock})\n\t  this._ws.send(packed)\n\t\n\t  // XXX: reject\n\t  return Q.Promise(function (resolve, reject) {\n\t    this._ev.on('notice', function (data) {\n\t      if (data.msg === 'done' && data.func === 'stop') {\n\t        resolve(data)\n\t      }\n\t    })\n\t  }.bind(this))\n\t}\n\t//\n\t// lock\n\t//\n\tWebmo.prototype.lock = function lock (smooth) {\n\t  var packed = JSON.stringify({type: 'lock', smooth: smooth})\n\t  this._ws.send(packed)\n\t}\n\t\n\tWebmo.prototype.unlock = function unlock () {\n\t  var packed = JSON.stringify({type: 'unlock'})\n\t  this._ws.send(packed)\n\t}\n\t\n\t//\n\t// goodies\n\t//\n\tWebmo.prototype.tick = function tick (timeMs) {\n\t  var packed = JSON.stringify({type: 'tick', timeMs: timeMs})\n\t  this._ws.send(packed)\n\t}\n\t\n\t//\n\t// Home\n\t//\n\tWebmo.prototype.resetHome = function resetHome () {\n\t  console.log('not impl')\n\t}\n\t\n\t// helper function\n\tWebmo.prototype.degreeToStep = function degreeToStep (degree) {\n\t  return degree / this.stepDegree\n\t}\n\t\n\tWebmo.prototype.stepToDegree = function stepToDegree (step) {\n\t  return step * this.stepDegree / 128 // XXX: microstep must be supplied\n\t}\n\t\n\tWebmo.prototype.getSpeedPerSecondByStep = function getSpeedPerSecondByStep (step) {\n\t  return Math.pow(2, 28) * step / Math.pow(10, 9) * 250\n\t}\n\t\n\tWebmo.prototype.getSpeedPerSecondByDegree = function getSpeedPerSecondByDegree (degree) {\n\t  return this.getSpeedPerSecondByStep(this.degreeToStep(degree))\n\t}\n\t\n\tmodule.exports = Webmo\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n\t * EventEmitter2\r\n\t * https://github.com/hij1nx/EventEmitter2\r\n\t *\r\n\t * Copyright (c) 2013 hij1nx\r\n\t * Licensed under the MIT license.\r\n\t */\r\n\t;!function(undefined) {\r\n\t\r\n\t  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\r\n\t    return Object.prototype.toString.call(obj) === \"[object Array]\";\r\n\t  };\r\n\t  var defaultMaxListeners = 10;\r\n\t\r\n\t  function init() {\r\n\t    this._events = {};\r\n\t    if (this._conf) {\r\n\t      configure.call(this, this._conf);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  function configure(conf) {\r\n\t    if (conf) {\r\n\t\r\n\t      this._conf = conf;\r\n\t\r\n\t      conf.delimiter && (this.delimiter = conf.delimiter);\r\n\t      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\r\n\t      conf.wildcard && (this.wildcard = conf.wildcard);\r\n\t      conf.newListener && (this.newListener = conf.newListener);\r\n\t\r\n\t      if (this.wildcard) {\r\n\t        this.listenerTree = {};\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  function EventEmitter(conf) {\r\n\t    this._events = {};\r\n\t    this.newListener = false;\r\n\t    configure.call(this, conf);\r\n\t  }\r\n\t  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\r\n\t\r\n\t  //\r\n\t  // Attention, function return type now is array, always !\r\n\t  // It has zero elements if no any matches found and one or more\r\n\t  // elements (leafs) if there are matches\r\n\t  //\r\n\t  function searchListenerTree(handlers, type, tree, i) {\r\n\t    if (!tree) {\r\n\t      return [];\r\n\t    }\r\n\t    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\r\n\t        typeLength = type.length, currentType = type[i], nextType = type[i+1];\r\n\t    if (i === typeLength && tree._listeners) {\r\n\t      //\r\n\t      // If at the end of the event(s) list and the tree has listeners\r\n\t      // invoke those listeners.\r\n\t      //\r\n\t      if (typeof tree._listeners === 'function') {\r\n\t        handlers && handlers.push(tree._listeners);\r\n\t        return [tree];\r\n\t      } else {\r\n\t        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\r\n\t          handlers && handlers.push(tree._listeners[leaf]);\r\n\t        }\r\n\t        return [tree];\r\n\t      }\r\n\t    }\r\n\t\r\n\t    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\r\n\t      //\r\n\t      // If the event emitted is '*' at this part\r\n\t      // or there is a concrete match at this patch\r\n\t      //\r\n\t      if (currentType === '*') {\r\n\t        for (branch in tree) {\r\n\t          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n\t            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\r\n\t          }\r\n\t        }\r\n\t        return listeners;\r\n\t      } else if(currentType === '**') {\r\n\t        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\r\n\t        if(endReached && tree._listeners) {\r\n\t          // The next element has a _listeners, add it to the handlers.\r\n\t          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\r\n\t        }\r\n\t\r\n\t        for (branch in tree) {\r\n\t          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n\t            if(branch === '*' || branch === '**') {\r\n\t              if(tree[branch]._listeners && !endReached) {\r\n\t                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\r\n\t              }\r\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n\t            } else if(branch === nextType) {\r\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\r\n\t            } else {\r\n\t              // No match on this one, shift into the tree but not in the type array.\r\n\t              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t        return listeners;\r\n\t      }\r\n\t\r\n\t      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\r\n\t    }\r\n\t\r\n\t    xTree = tree['*'];\r\n\t    if (xTree) {\r\n\t      //\r\n\t      // If the listener tree will allow any match for this part,\r\n\t      // then recursively explore all branches of the tree\r\n\t      //\r\n\t      searchListenerTree(handlers, type, xTree, i+1);\r\n\t    }\r\n\t\r\n\t    xxTree = tree['**'];\r\n\t    if(xxTree) {\r\n\t      if(i < typeLength) {\r\n\t        if(xxTree._listeners) {\r\n\t          // If we have a listener on a '**', it will catch all, so add its handler.\r\n\t          searchListenerTree(handlers, type, xxTree, typeLength);\r\n\t        }\r\n\t\r\n\t        // Build arrays of matching next branches and others.\r\n\t        for(branch in xxTree) {\r\n\t          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\r\n\t            if(branch === nextType) {\r\n\t              // We know the next element will match, so jump twice.\r\n\t              searchListenerTree(handlers, type, xxTree[branch], i+2);\r\n\t            } else if(branch === currentType) {\r\n\t              // Current node matches, move into the tree.\r\n\t              searchListenerTree(handlers, type, xxTree[branch], i+1);\r\n\t            } else {\r\n\t              isolatedBranch = {};\r\n\t              isolatedBranch[branch] = xxTree[branch];\r\n\t              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      } else if(xxTree._listeners) {\r\n\t        // We have reached the end and still on a '**'\r\n\t        searchListenerTree(handlers, type, xxTree, typeLength);\r\n\t      } else if(xxTree['*'] && xxTree['*']._listeners) {\r\n\t        searchListenerTree(handlers, type, xxTree['*'], typeLength);\r\n\t      }\r\n\t    }\r\n\t\r\n\t    return listeners;\r\n\t  }\r\n\t\r\n\t  function growListenerTree(type, listener) {\r\n\t\r\n\t    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\t\r\n\t    //\r\n\t    // Looks for two consecutive '**', if so, don't add the event at all.\r\n\t    //\r\n\t    for(var i = 0, len = type.length; i+1 < len; i++) {\r\n\t      if(type[i] === '**' && type[i+1] === '**') {\r\n\t        return;\r\n\t      }\r\n\t    }\r\n\t\r\n\t    var tree = this.listenerTree;\r\n\t    var name = type.shift();\r\n\t\r\n\t    while (name) {\r\n\t\r\n\t      if (!tree[name]) {\r\n\t        tree[name] = {};\r\n\t      }\r\n\t\r\n\t      tree = tree[name];\r\n\t\r\n\t      if (type.length === 0) {\r\n\t\r\n\t        if (!tree._listeners) {\r\n\t          tree._listeners = listener;\r\n\t        }\r\n\t        else if(typeof tree._listeners === 'function') {\r\n\t          tree._listeners = [tree._listeners, listener];\r\n\t        }\r\n\t        else if (isArray(tree._listeners)) {\r\n\t\r\n\t          tree._listeners.push(listener);\r\n\t\r\n\t          if (!tree._listeners.warned) {\r\n\t\r\n\t            var m = defaultMaxListeners;\r\n\t\r\n\t            if (typeof this._events.maxListeners !== 'undefined') {\r\n\t              m = this._events.maxListeners;\r\n\t            }\r\n\t\r\n\t            if (m > 0 && tree._listeners.length > m) {\r\n\t\r\n\t              tree._listeners.warned = true;\r\n\t              console.error('(node) warning: possible EventEmitter memory ' +\r\n\t                            'leak detected. %d listeners added. ' +\r\n\t                            'Use emitter.setMaxListeners() to increase limit.',\r\n\t                            tree._listeners.length);\r\n\t              if(console.trace){\r\n\t                console.trace();\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t        return true;\r\n\t      }\r\n\t      name = type.shift();\r\n\t    }\r\n\t    return true;\r\n\t  }\r\n\t\r\n\t  // By default EventEmitters will print a warning if more than\r\n\t  // 10 listeners are added to it. This is a useful default which\r\n\t  // helps finding memory leaks.\r\n\t  //\r\n\t  // Obviously not all Emitters should be limited to 10. This function allows\r\n\t  // that to be increased. Set to zero for unlimited.\r\n\t\r\n\t  EventEmitter.prototype.delimiter = '.';\r\n\t\r\n\t  EventEmitter.prototype.setMaxListeners = function(n) {\r\n\t    this._events || init.call(this);\r\n\t    this._events.maxListeners = n;\r\n\t    if (!this._conf) this._conf = {};\r\n\t    this._conf.maxListeners = n;\r\n\t  };\r\n\t\r\n\t  EventEmitter.prototype.event = '';\r\n\t\r\n\t  EventEmitter.prototype.once = function(event, fn) {\r\n\t    this.many(event, 1, fn);\r\n\t    return this;\r\n\t  };\r\n\t\r\n\t  EventEmitter.prototype.many = function(event, ttl, fn) {\r\n\t    var self = this;\r\n\t\r\n\t    if (typeof fn !== 'function') {\r\n\t      throw new Error('many only accepts instances of Function');\r\n\t    }\r\n\t\r\n\t    function listener() {\r\n\t      if (--ttl === 0) {\r\n\t        self.off(event, listener);\r\n\t      }\r\n\t      fn.apply(this, arguments);\r\n\t    }\r\n\t\r\n\t    listener._origin = fn;\r\n\t\r\n\t    this.on(event, listener);\r\n\t\r\n\t    return self;\r\n\t  };\r\n\t\r\n\t  EventEmitter.prototype.emit = function() {\r\n\t\r\n\t    this._events || init.call(this);\r\n\t\r\n\t    var type = arguments[0];\r\n\t\r\n\t    if (type === 'newListener' && !this.newListener) {\r\n\t      if (!this._events.newListener) { return false; }\r\n\t    }\r\n\t\r\n\t    // Loop through the *_all* functions and invoke them.\r\n\t    if (this._all) {\r\n\t      var l = arguments.length;\r\n\t      var args = new Array(l - 1);\r\n\t      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n\t      for (i = 0, l = this._all.length; i < l; i++) {\r\n\t        this.event = type;\r\n\t        this._all[i].apply(this, [type].concat(args));\r\n\t      }\r\n\t    }\r\n\t\r\n\t    // If there is no 'error' event listener then throw.\r\n\t    if (type === 'error') {\r\n\t\r\n\t      if (!this._all &&\r\n\t        !this._events.error &&\r\n\t        !(this.wildcard && this.listenerTree.error)) {\r\n\t\r\n\t        if (arguments[1] instanceof Error) {\r\n\t          throw arguments[1]; // Unhandled 'error' event\r\n\t        } else {\r\n\t          throw new Error(\"Uncaught, unspecified 'error' event.\");\r\n\t        }\r\n\t        return false;\r\n\t      }\r\n\t    }\r\n\t\r\n\t    var handler;\r\n\t\r\n\t    if(this.wildcard) {\r\n\t      handler = [];\r\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\t      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n\t    }\r\n\t    else {\r\n\t      handler = this._events[type];\r\n\t    }\r\n\t\r\n\t    if (typeof handler === 'function') {\r\n\t      this.event = type;\r\n\t      if (arguments.length === 1) {\r\n\t        handler.call(this);\r\n\t      }\r\n\t      else if (arguments.length > 1)\r\n\t        switch (arguments.length) {\r\n\t          case 2:\r\n\t            handler.call(this, arguments[1]);\r\n\t            break;\r\n\t          case 3:\r\n\t            handler.call(this, arguments[1], arguments[2]);\r\n\t            break;\r\n\t          // slower\r\n\t          default:\r\n\t            var l = arguments.length;\r\n\t            var args = new Array(l - 1);\r\n\t            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n\t            handler.apply(this, args);\r\n\t        }\r\n\t      return true;\r\n\t    }\r\n\t    else if (handler) {\r\n\t      var l = arguments.length;\r\n\t      var args = new Array(l - 1);\r\n\t      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n\t\r\n\t      var listeners = handler.slice();\r\n\t      for (var i = 0, l = listeners.length; i < l; i++) {\r\n\t        this.event = type;\r\n\t        listeners[i].apply(this, args);\r\n\t      }\r\n\t      return (listeners.length > 0) || !!this._all;\r\n\t    }\r\n\t    else {\r\n\t      return !!this._all;\r\n\t    }\r\n\t\r\n\t  };\r\n\t\r\n\t  EventEmitter.prototype.emitAsync = function() {\r\n\t\r\n\t    this._events || init.call(this);\r\n\t\r\n\t    var type = arguments[0];\r\n\t\r\n\t    if (type === 'newListener' && !this.newListener) {\r\n\t      if (!this._events.newListener) { return Promise.resolve([false]); }\r\n\t    }\r\n\t\r\n\t    var promises= [];\r\n\t\r\n\t    // Loop through the *_all* functions and invoke them.\r\n\t    if (this._all) {\r\n\t      var l = arguments.length;\r\n\t      var args = new Array(l - 1);\r\n\t      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n\t      for (i = 0, l = this._all.length; i < l; i++) {\r\n\t        this.event = type;\r\n\t        promises.push(this._all[i].apply(this, args));\r\n\t      }\r\n\t    }\r\n\t\r\n\t    // If there is no 'error' event listener then throw.\r\n\t    if (type === 'error') {\r\n\t\r\n\t      if (!this._all &&\r\n\t        !this._events.error &&\r\n\t        !(this.wildcard && this.listenerTree.error)) {\r\n\t\r\n\t        if (arguments[1] instanceof Error) {\r\n\t          return Promise.reject(arguments[1]); // Unhandled 'error' event\r\n\t        } else {\r\n\t          return Promise.reject(\"Uncaught, unspecified 'error' event.\");\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t\r\n\t    var handler;\r\n\t\r\n\t    if(this.wildcard) {\r\n\t      handler = [];\r\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\t      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n\t    }\r\n\t    else {\r\n\t      handler = this._events[type];\r\n\t    }\r\n\t\r\n\t    if (typeof handler === 'function') {\r\n\t      this.event = type;\r\n\t      if (arguments.length === 1) {\r\n\t        promises.push(handler.call(this));\r\n\t      }\r\n\t      else if (arguments.length > 1) {\r\n\t        switch (arguments.length) {\r\n\t          case 2:\r\n\t            promises.push(handler.call(this, arguments[1]));\r\n\t            break;\r\n\t          case 3:\r\n\t            promises.push(handler.call(this, arguments[1], arguments[2]));\r\n\t            break;\r\n\t          // slower\r\n\t          default:\r\n\t            var l = arguments.length;\r\n\t            var args = new Array(l - 1);\r\n\t            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n\t            promises.push(handler.apply(this, args));\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t    else if (handler) {\r\n\t      var l = arguments.length;\r\n\t      var args = new Array(l - 1);\r\n\t      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n\t\r\n\t      var listeners = handler.slice();\r\n\t      for (var i = 0, l = listeners.length; i < l; i++) {\r\n\t        this.event = type;\r\n\t        promises.push(listeners[i].apply(this, args));\r\n\t      }\r\n\t    }\r\n\t    return Promise.all(promises);\r\n\t  };\r\n\t\r\n\t  EventEmitter.prototype.on = function(type, listener) {\r\n\t\r\n\t    if (typeof type === 'function') {\r\n\t      this.onAny(type);\r\n\t      return this;\r\n\t    }\r\n\t\r\n\t    if (typeof listener !== 'function') {\r\n\t      throw new Error('on only accepts instances of Function');\r\n\t    }\r\n\t    this._events || init.call(this);\r\n\t\r\n\t    // To avoid recursion in the case that type == \"newListeners\"! Before\r\n\t    // adding it to the listeners, first emit \"newListeners\".\r\n\t    this.emit('newListener', type, listener);\r\n\t\r\n\t    if(this.wildcard) {\r\n\t      growListenerTree.call(this, type, listener);\r\n\t      return this;\r\n\t    }\r\n\t\r\n\t    if (!this._events[type]) {\r\n\t      // Optimize the case of one listener. Don't need the extra array object.\r\n\t      this._events[type] = listener;\r\n\t    }\r\n\t    else if(typeof this._events[type] === 'function') {\r\n\t      // Adding the second element, need to change to array.\r\n\t      this._events[type] = [this._events[type], listener];\r\n\t    }\r\n\t    else if (isArray(this._events[type])) {\r\n\t      // If we've already got an array, just append.\r\n\t      this._events[type].push(listener);\r\n\t\r\n\t      // Check for listener leak\r\n\t      if (!this._events[type].warned) {\r\n\t\r\n\t        var m = defaultMaxListeners;\r\n\t\r\n\t        if (typeof this._events.maxListeners !== 'undefined') {\r\n\t          m = this._events.maxListeners;\r\n\t        }\r\n\t\r\n\t        if (m > 0 && this._events[type].length > m) {\r\n\t\r\n\t          this._events[type].warned = true;\r\n\t          console.error('(node) warning: possible EventEmitter memory ' +\r\n\t                        'leak detected. %d listeners added. ' +\r\n\t                        'Use emitter.setMaxListeners() to increase limit.',\r\n\t                        this._events[type].length);\r\n\t          if(console.trace){\r\n\t            console.trace();\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t    return this;\r\n\t  };\r\n\t\r\n\t  EventEmitter.prototype.onAny = function(fn) {\r\n\t\r\n\t    if (typeof fn !== 'function') {\r\n\t      throw new Error('onAny only accepts instances of Function');\r\n\t    }\r\n\t\r\n\t    if(!this._all) {\r\n\t      this._all = [];\r\n\t    }\r\n\t\r\n\t    // Add the function to the event listener collection.\r\n\t    this._all.push(fn);\r\n\t    return this;\r\n\t  };\r\n\t\r\n\t  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\t\r\n\t  EventEmitter.prototype.off = function(type, listener) {\r\n\t    if (typeof listener !== 'function') {\r\n\t      throw new Error('removeListener only takes instances of Function');\r\n\t    }\r\n\t\r\n\t    var handlers,leafs=[];\r\n\t\r\n\t    if(this.wildcard) {\r\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\t      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n\t    }\r\n\t    else {\r\n\t      // does not use listeners(), so no side effect of creating _events[type]\r\n\t      if (!this._events[type]) return this;\r\n\t      handlers = this._events[type];\r\n\t      leafs.push({_listeners:handlers});\r\n\t    }\r\n\t\r\n\t    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n\t      var leaf = leafs[iLeaf];\r\n\t      handlers = leaf._listeners;\r\n\t      if (isArray(handlers)) {\r\n\t\r\n\t        var position = -1;\r\n\t\r\n\t        for (var i = 0, length = handlers.length; i < length; i++) {\r\n\t          if (handlers[i] === listener ||\r\n\t            (handlers[i].listener && handlers[i].listener === listener) ||\r\n\t            (handlers[i]._origin && handlers[i]._origin === listener)) {\r\n\t            position = i;\r\n\t            break;\r\n\t          }\r\n\t        }\r\n\t\r\n\t        if (position < 0) {\r\n\t          continue;\r\n\t        }\r\n\t\r\n\t        if(this.wildcard) {\r\n\t          leaf._listeners.splice(position, 1);\r\n\t        }\r\n\t        else {\r\n\t          this._events[type].splice(position, 1);\r\n\t        }\r\n\t\r\n\t        if (handlers.length === 0) {\r\n\t          if(this.wildcard) {\r\n\t            delete leaf._listeners;\r\n\t          }\r\n\t          else {\r\n\t            delete this._events[type];\r\n\t          }\r\n\t        }\r\n\t        \r\n\t        this.emit(\"removeListener\", type, listener);\r\n\t        \r\n\t        return this;\r\n\t      }\r\n\t      else if (handlers === listener ||\r\n\t        (handlers.listener && handlers.listener === listener) ||\r\n\t        (handlers._origin && handlers._origin === listener)) {\r\n\t        if(this.wildcard) {\r\n\t          delete leaf._listeners;\r\n\t        }\r\n\t        else {\r\n\t          delete this._events[type];\r\n\t        }\r\n\t        \r\n\t        this.emit(\"removeListener\", type, listener);\r\n\t      }\r\n\t    }\r\n\t\r\n\t    function recursivelyGarbageCollect(root) {\r\n\t      if (root === undefined) {\r\n\t        return;\r\n\t      }\r\n\t      var keys = Object.keys(root);\r\n\t      for (var i in keys) {\r\n\t        var key = keys[i];\r\n\t        var obj = root[key];\r\n\t        if ((obj instanceof Function) || (typeof obj !== \"object\"))\r\n\t          continue;\r\n\t        if (Object.keys(obj).length > 0) {\r\n\t          recursivelyGarbageCollect(root[key]);\r\n\t        }\r\n\t        if (Object.keys(obj).length === 0) {\r\n\t          delete root[key];\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t    recursivelyGarbageCollect(this.listenerTree);\r\n\t\r\n\t    return this;\r\n\t  };\r\n\t\r\n\t  EventEmitter.prototype.offAny = function(fn) {\r\n\t    var i = 0, l = 0, fns;\r\n\t    if (fn && this._all && this._all.length > 0) {\r\n\t      fns = this._all;\r\n\t      for(i = 0, l = fns.length; i < l; i++) {\r\n\t        if(fn === fns[i]) {\r\n\t          fns.splice(i, 1);\r\n\t          this.emit(\"removeListenerAny\", fn);\r\n\t          return this;\r\n\t        }\r\n\t      }\r\n\t    } else {\r\n\t      fns = this._all;\r\n\t      for(i = 0, l = fns.length; i < l; i++)\r\n\t        this.emit(\"removeListenerAny\", fns[i]);\r\n\t      this._all = [];\r\n\t    }\r\n\t    return this;\r\n\t  };\r\n\t\r\n\t  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\r\n\t\r\n\t  EventEmitter.prototype.removeAllListeners = function(type) {\r\n\t    if (arguments.length === 0) {\r\n\t      !this._events || init.call(this);\r\n\t      return this;\r\n\t    }\r\n\t\r\n\t    if(this.wildcard) {\r\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\t      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n\t\r\n\t      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n\t        var leaf = leafs[iLeaf];\r\n\t        leaf._listeners = null;\r\n\t      }\r\n\t    }\r\n\t    else {\r\n\t      if (!this._events || !this._events[type]) return this;\r\n\t      this._events[type] = null;\r\n\t    }\r\n\t    return this;\r\n\t  };\r\n\t\r\n\t  EventEmitter.prototype.listeners = function(type) {\r\n\t    if(this.wildcard) {\r\n\t      var handlers = [];\r\n\t      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\t      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\r\n\t      return handlers;\r\n\t    }\r\n\t\r\n\t    this._events || init.call(this);\r\n\t\r\n\t    if (!this._events[type]) this._events[type] = [];\r\n\t    if (!isArray(this._events[type])) {\r\n\t      this._events[type] = [this._events[type]];\r\n\t    }\r\n\t    return this._events[type];\r\n\t  };\r\n\t\r\n\t  EventEmitter.prototype.listenersAny = function() {\r\n\t\r\n\t    if(this._all) {\r\n\t      return this._all;\r\n\t    }\r\n\t    else {\r\n\t      return [];\r\n\t    }\r\n\t\r\n\t  };\r\n\t\r\n\t  if (true) {\r\n\t     // AMD. Register as an anonymous module.\r\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\r\n\t      return EventEmitter;\r\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t  } else if (typeof exports === 'object') {\r\n\t    // CommonJS\r\n\t    module.exports = EventEmitter;\r\n\t  }\r\n\t  else {\r\n\t    // Browser global.\r\n\t    window.EventEmitter2 = EventEmitter;\r\n\t  }\r\n\t}();\r\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// vim:ts=4:sts=4:sw=4:\n\t/*!\n\t *\n\t * Copyright 2009-2012 Kris Kowal under the terms of the MIT\n\t * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n\t *\n\t * With parts by Tyler Close\n\t * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n\t * at http://www.opensource.org/licenses/mit-license.html\n\t * Forked at ref_send.js version: 2009-05-11\n\t *\n\t * With parts by Mark Miller\n\t * Copyright (C) 2011 Google Inc.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t *\n\t */\n\t\n\t(function (definition) {\n\t    \"use strict\";\n\t\n\t    // This file will function properly as a <script> tag, or a module\n\t    // using CommonJS and NodeJS or RequireJS module formats.  In\n\t    // Common/Node/RequireJS, the module exports the Q API and when\n\t    // executed as a simple <script>, it creates a Q global instead.\n\t\n\t    // Montage Require\n\t    if (typeof bootstrap === \"function\") {\n\t        bootstrap(\"promise\", definition);\n\t\n\t    // CommonJS\n\t    } else if (true) {\n\t        module.exports = definition();\n\t\n\t    // RequireJS\n\t    } else if (typeof define === \"function\" && define.amd) {\n\t        define(definition);\n\t\n\t    // SES (Secure EcmaScript)\n\t    } else if (typeof ses !== \"undefined\") {\n\t        if (!ses.ok()) {\n\t            return;\n\t        } else {\n\t            ses.makeQ = definition;\n\t        }\n\t\n\t    // <script>\n\t    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n\t        // Prefer window over self for add-on scripts. Use self for\n\t        // non-windowed contexts.\n\t        var global = typeof window !== \"undefined\" ? window : self;\n\t\n\t        // Get the `window` object, save the previous Q global\n\t        // and initialize Q as a global.\n\t        var previousQ = global.Q;\n\t        global.Q = definition();\n\t\n\t        // Add a noConflict function so Q can be removed from the\n\t        // global namespace.\n\t        global.Q.noConflict = function () {\n\t            global.Q = previousQ;\n\t            return this;\n\t        };\n\t\n\t    } else {\n\t        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n\t    }\n\t\n\t})(function () {\n\t\"use strict\";\n\t\n\tvar hasStacks = false;\n\ttry {\n\t    throw new Error();\n\t} catch (e) {\n\t    hasStacks = !!e.stack;\n\t}\n\t\n\t// All code after this point will be filtered from stack traces reported\n\t// by Q.\n\tvar qStartingLine = captureLine();\n\tvar qFileName;\n\t\n\t// shims\n\t\n\t// used for fallback in \"allResolved\"\n\tvar noop = function () {};\n\t\n\t// Use the fastest possible means to execute a task in a future turn\n\t// of the event loop.\n\tvar nextTick =(function () {\n\t    // linked list of tasks (single, with head node)\n\t    var head = {task: void 0, next: null};\n\t    var tail = head;\n\t    var flushing = false;\n\t    var requestTick = void 0;\n\t    var isNodeJS = false;\n\t    // queue for late tasks, used by unhandled rejection tracking\n\t    var laterQueue = [];\n\t\n\t    function flush() {\n\t        /* jshint loopfunc: true */\n\t        var task, domain;\n\t\n\t        while (head.next) {\n\t            head = head.next;\n\t            task = head.task;\n\t            head.task = void 0;\n\t            domain = head.domain;\n\t\n\t            if (domain) {\n\t                head.domain = void 0;\n\t                domain.enter();\n\t            }\n\t            runSingle(task, domain);\n\t\n\t        }\n\t        while (laterQueue.length) {\n\t            task = laterQueue.pop();\n\t            runSingle(task);\n\t        }\n\t        flushing = false;\n\t    }\n\t    // runs a single function in the async queue\n\t    function runSingle(task, domain) {\n\t        try {\n\t            task();\n\t\n\t        } catch (e) {\n\t            if (isNodeJS) {\n\t                // In node, uncaught exceptions are considered fatal errors.\n\t                // Re-throw them synchronously to interrupt flushing!\n\t\n\t                // Ensure continuation if the uncaught exception is suppressed\n\t                // listening \"uncaughtException\" events (as domains does).\n\t                // Continue in next event to avoid tick recursion.\n\t                if (domain) {\n\t                    domain.exit();\n\t                }\n\t                setTimeout(flush, 0);\n\t                if (domain) {\n\t                    domain.enter();\n\t                }\n\t\n\t                throw e;\n\t\n\t            } else {\n\t                // In browsers, uncaught exceptions are not fatal.\n\t                // Re-throw them asynchronously to avoid slow-downs.\n\t                setTimeout(function () {\n\t                    throw e;\n\t                }, 0);\n\t            }\n\t        }\n\t\n\t        if (domain) {\n\t            domain.exit();\n\t        }\n\t    }\n\t\n\t    nextTick = function (task) {\n\t        tail = tail.next = {\n\t            task: task,\n\t            domain: isNodeJS && process.domain,\n\t            next: null\n\t        };\n\t\n\t        if (!flushing) {\n\t            flushing = true;\n\t            requestTick();\n\t        }\n\t    };\n\t\n\t    if (typeof process === \"object\" &&\n\t        process.toString() === \"[object process]\" && process.nextTick) {\n\t        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n\t        // To see through fake Node environments:\n\t        // * Mocha test runner - exposes a `process` global without a `nextTick`\n\t        // * Browserify - exposes a `process.nexTick` function that uses\n\t        //   `setTimeout`. In this case `setImmediate` is preferred because\n\t        //    it is faster. Browserify's `process.toString()` yields\n\t        //   \"[object Object]\", while in a real Node environment\n\t        //   `process.nextTick()` yields \"[object process]\".\n\t        isNodeJS = true;\n\t\n\t        requestTick = function () {\n\t            process.nextTick(flush);\n\t        };\n\t\n\t    } else if (typeof setImmediate === \"function\") {\n\t        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n\t        if (typeof window !== \"undefined\") {\n\t            requestTick = setImmediate.bind(window, flush);\n\t        } else {\n\t            requestTick = function () {\n\t                setImmediate(flush);\n\t            };\n\t        }\n\t\n\t    } else if (typeof MessageChannel !== \"undefined\") {\n\t        // modern browsers\n\t        // http://www.nonblocking.io/2011/06/windownexttick.html\n\t        var channel = new MessageChannel();\n\t        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n\t        // working message ports the first time a page loads.\n\t        channel.port1.onmessage = function () {\n\t            requestTick = requestPortTick;\n\t            channel.port1.onmessage = flush;\n\t            flush();\n\t        };\n\t        var requestPortTick = function () {\n\t            // Opera requires us to provide a message payload, regardless of\n\t            // whether we use it.\n\t            channel.port2.postMessage(0);\n\t        };\n\t        requestTick = function () {\n\t            setTimeout(flush, 0);\n\t            requestPortTick();\n\t        };\n\t\n\t    } else {\n\t        // old browsers\n\t        requestTick = function () {\n\t            setTimeout(flush, 0);\n\t        };\n\t    }\n\t    // runs a task after all other tasks have been run\n\t    // this is useful for unhandled rejection tracking that needs to happen\n\t    // after all `then`d tasks have been run.\n\t    nextTick.runAfter = function (task) {\n\t        laterQueue.push(task);\n\t        if (!flushing) {\n\t            flushing = true;\n\t            requestTick();\n\t        }\n\t    };\n\t    return nextTick;\n\t})();\n\t\n\t// Attempt to make generics safe in the face of downstream\n\t// modifications.\n\t// There is no situation where this is necessary.\n\t// If you need a security guarantee, these primordials need to be\n\t// deeply frozen anyway, and if you dont need a security guarantee,\n\t// this is just plain paranoid.\n\t// However, this **might** have the nice side-effect of reducing the size of\n\t// the minified code by reducing x.call() to merely x()\n\t// See Mark Millers explanation of what this does.\n\t// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n\tvar call = Function.call;\n\tfunction uncurryThis(f) {\n\t    return function () {\n\t        return call.apply(f, arguments);\n\t    };\n\t}\n\t// This is equivalent, but slower:\n\t// uncurryThis = Function_bind.bind(Function_bind.call);\n\t// http://jsperf.com/uncurrythis\n\t\n\tvar array_slice = uncurryThis(Array.prototype.slice);\n\t\n\tvar array_reduce = uncurryThis(\n\t    Array.prototype.reduce || function (callback, basis) {\n\t        var index = 0,\n\t            length = this.length;\n\t        // concerning the initial value, if one is not provided\n\t        if (arguments.length === 1) {\n\t            // seek to the first value in the array, accounting\n\t            // for the possibility that is is a sparse array\n\t            do {\n\t                if (index in this) {\n\t                    basis = this[index++];\n\t                    break;\n\t                }\n\t                if (++index >= length) {\n\t                    throw new TypeError();\n\t                }\n\t            } while (1);\n\t        }\n\t        // reduce\n\t        for (; index < length; index++) {\n\t            // account for the possibility that the array is sparse\n\t            if (index in this) {\n\t                basis = callback(basis, this[index], index);\n\t            }\n\t        }\n\t        return basis;\n\t    }\n\t);\n\t\n\tvar array_indexOf = uncurryThis(\n\t    Array.prototype.indexOf || function (value) {\n\t        // not a very good shim, but good enough for our one use of it\n\t        for (var i = 0; i < this.length; i++) {\n\t            if (this[i] === value) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t);\n\t\n\tvar array_map = uncurryThis(\n\t    Array.prototype.map || function (callback, thisp) {\n\t        var self = this;\n\t        var collect = [];\n\t        array_reduce(self, function (undefined, value, index) {\n\t            collect.push(callback.call(thisp, value, index, self));\n\t        }, void 0);\n\t        return collect;\n\t    }\n\t);\n\t\n\tvar object_create = Object.create || function (prototype) {\n\t    function Type() { }\n\t    Type.prototype = prototype;\n\t    return new Type();\n\t};\n\t\n\tvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\t\n\tvar object_keys = Object.keys || function (object) {\n\t    var keys = [];\n\t    for (var key in object) {\n\t        if (object_hasOwnProperty(object, key)) {\n\t            keys.push(key);\n\t        }\n\t    }\n\t    return keys;\n\t};\n\t\n\tvar object_toString = uncurryThis(Object.prototype.toString);\n\t\n\tfunction isObject(value) {\n\t    return value === Object(value);\n\t}\n\t\n\t// generator related shims\n\t\n\t// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\n\tfunction isStopIteration(exception) {\n\t    return (\n\t        object_toString(exception) === \"[object StopIteration]\" ||\n\t        exception instanceof QReturnValue\n\t    );\n\t}\n\t\n\t// FIXME: Remove this helper and Q.return once ES6 generators are in\n\t// SpiderMonkey.\n\tvar QReturnValue;\n\tif (typeof ReturnValue !== \"undefined\") {\n\t    QReturnValue = ReturnValue;\n\t} else {\n\t    QReturnValue = function (value) {\n\t        this.value = value;\n\t    };\n\t}\n\t\n\t// long stack traces\n\t\n\tvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\t\n\tfunction makeStackTraceLong(error, promise) {\n\t    // If possible, transform the error stack trace by removing Node and Q\n\t    // cruft, then concatenating with the stack trace of `promise`. See #57.\n\t    if (hasStacks &&\n\t        promise.stack &&\n\t        typeof error === \"object\" &&\n\t        error !== null &&\n\t        error.stack &&\n\t        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n\t    ) {\n\t        var stacks = [];\n\t        for (var p = promise; !!p; p = p.source) {\n\t            if (p.stack) {\n\t                stacks.unshift(p.stack);\n\t            }\n\t        }\n\t        stacks.unshift(error.stack);\n\t\n\t        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n\t        error.stack = filterStackString(concatedStacks);\n\t    }\n\t}\n\t\n\tfunction filterStackString(stackString) {\n\t    var lines = stackString.split(\"\\n\");\n\t    var desiredLines = [];\n\t    for (var i = 0; i < lines.length; ++i) {\n\t        var line = lines[i];\n\t\n\t        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n\t            desiredLines.push(line);\n\t        }\n\t    }\n\t    return desiredLines.join(\"\\n\");\n\t}\n\t\n\tfunction isNodeFrame(stackLine) {\n\t    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n\t           stackLine.indexOf(\"(node.js:\") !== -1;\n\t}\n\t\n\tfunction getFileNameAndLineNumber(stackLine) {\n\t    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n\t    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n\t    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n\t    if (attempt1) {\n\t        return [attempt1[1], Number(attempt1[2])];\n\t    }\n\t\n\t    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n\t    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n\t    if (attempt2) {\n\t        return [attempt2[1], Number(attempt2[2])];\n\t    }\n\t\n\t    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n\t    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n\t    if (attempt3) {\n\t        return [attempt3[1], Number(attempt3[2])];\n\t    }\n\t}\n\t\n\tfunction isInternalFrame(stackLine) {\n\t    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\t\n\t    if (!fileNameAndLineNumber) {\n\t        return false;\n\t    }\n\t\n\t    var fileName = fileNameAndLineNumber[0];\n\t    var lineNumber = fileNameAndLineNumber[1];\n\t\n\t    return fileName === qFileName &&\n\t        lineNumber >= qStartingLine &&\n\t        lineNumber <= qEndingLine;\n\t}\n\t\n\t// discover own file name and line number range for filtering stack\n\t// traces\n\tfunction captureLine() {\n\t    if (!hasStacks) {\n\t        return;\n\t    }\n\t\n\t    try {\n\t        throw new Error();\n\t    } catch (e) {\n\t        var lines = e.stack.split(\"\\n\");\n\t        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n\t        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n\t        if (!fileNameAndLineNumber) {\n\t            return;\n\t        }\n\t\n\t        qFileName = fileNameAndLineNumber[0];\n\t        return fileNameAndLineNumber[1];\n\t    }\n\t}\n\t\n\tfunction deprecate(callback, name, alternative) {\n\t    return function () {\n\t        if (typeof console !== \"undefined\" &&\n\t            typeof console.warn === \"function\") {\n\t            console.warn(name + \" is deprecated, use \" + alternative +\n\t                         \" instead.\", new Error(\"\").stack);\n\t        }\n\t        return callback.apply(callback, arguments);\n\t    };\n\t}\n\t\n\t// end of shims\n\t// beginning of real work\n\t\n\t/**\n\t * Constructs a promise for an immediate reference, passes promises through, or\n\t * coerces promises from different systems.\n\t * @param value immediate reference or promise\n\t */\n\tfunction Q(value) {\n\t    // If the object is already a Promise, return it directly.  This enables\n\t    // the resolve function to both be used to created references from objects,\n\t    // but to tolerably coerce non-promises to promises.\n\t    if (value instanceof Promise) {\n\t        return value;\n\t    }\n\t\n\t    // assimilate thenables\n\t    if (isPromiseAlike(value)) {\n\t        return coerce(value);\n\t    } else {\n\t        return fulfill(value);\n\t    }\n\t}\n\tQ.resolve = Q;\n\t\n\t/**\n\t * Performs a task in a future turn of the event loop.\n\t * @param {Function} task\n\t */\n\tQ.nextTick = nextTick;\n\t\n\t/**\n\t * Controls whether or not long stack traces will be on\n\t */\n\tQ.longStackSupport = false;\n\t\n\t// enable long stacks if Q_DEBUG is set\n\tif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n\t    Q.longStackSupport = true;\n\t}\n\t\n\t/**\n\t * Constructs a {promise, resolve, reject} object.\n\t *\n\t * `resolve` is a callback to invoke with a more resolved value for the\n\t * promise. To fulfill the promise, invoke `resolve` with any value that is\n\t * not a thenable. To reject the promise, invoke `resolve` with a rejected\n\t * thenable, or invoke `reject` with the reason directly. To resolve the\n\t * promise to another thenable, thus putting it in the same state, invoke\n\t * `resolve` with that other thenable.\n\t */\n\tQ.defer = defer;\n\tfunction defer() {\n\t    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n\t    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n\t    // element of the messages array is itself an array of complete arguments to\n\t    // forward to the resolved promise.  We coerce the resolution value to a\n\t    // promise using the `resolve` function because it handles both fully\n\t    // non-thenable values and other thenables gracefully.\n\t    var messages = [], progressListeners = [], resolvedPromise;\n\t\n\t    var deferred = object_create(defer.prototype);\n\t    var promise = object_create(Promise.prototype);\n\t\n\t    promise.promiseDispatch = function (resolve, op, operands) {\n\t        var args = array_slice(arguments);\n\t        if (messages) {\n\t            messages.push(args);\n\t            if (op === \"when\" && operands[1]) { // progress operand\n\t                progressListeners.push(operands[1]);\n\t            }\n\t        } else {\n\t            Q.nextTick(function () {\n\t                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n\t            });\n\t        }\n\t    };\n\t\n\t    // XXX deprecated\n\t    promise.valueOf = function () {\n\t        if (messages) {\n\t            return promise;\n\t        }\n\t        var nearerValue = nearer(resolvedPromise);\n\t        if (isPromise(nearerValue)) {\n\t            resolvedPromise = nearerValue; // shorten chain\n\t        }\n\t        return nearerValue;\n\t    };\n\t\n\t    promise.inspect = function () {\n\t        if (!resolvedPromise) {\n\t            return { state: \"pending\" };\n\t        }\n\t        return resolvedPromise.inspect();\n\t    };\n\t\n\t    if (Q.longStackSupport && hasStacks) {\n\t        try {\n\t            throw new Error();\n\t        } catch (e) {\n\t            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n\t            // accessor around; that causes memory leaks as per GH-111. Just\n\t            // reify the stack trace as a string ASAP.\n\t            //\n\t            // At the same time, cut off the first line; it's always just\n\t            // \"[object Promise]\\n\", as per the `toString`.\n\t            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n\t        }\n\t    }\n\t\n\t    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n\t    // consolidating them into `become`, since otherwise we'd create new\n\t    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\t\n\t    function become(newPromise) {\n\t        resolvedPromise = newPromise;\n\t        promise.source = newPromise;\n\t\n\t        array_reduce(messages, function (undefined, message) {\n\t            Q.nextTick(function () {\n\t                newPromise.promiseDispatch.apply(newPromise, message);\n\t            });\n\t        }, void 0);\n\t\n\t        messages = void 0;\n\t        progressListeners = void 0;\n\t    }\n\t\n\t    deferred.promise = promise;\n\t    deferred.resolve = function (value) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(Q(value));\n\t    };\n\t\n\t    deferred.fulfill = function (value) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(fulfill(value));\n\t    };\n\t    deferred.reject = function (reason) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        become(reject(reason));\n\t    };\n\t    deferred.notify = function (progress) {\n\t        if (resolvedPromise) {\n\t            return;\n\t        }\n\t\n\t        array_reduce(progressListeners, function (undefined, progressListener) {\n\t            Q.nextTick(function () {\n\t                progressListener(progress);\n\t            });\n\t        }, void 0);\n\t    };\n\t\n\t    return deferred;\n\t}\n\t\n\t/**\n\t * Creates a Node-style callback that will resolve or reject the deferred\n\t * promise.\n\t * @returns a nodeback\n\t */\n\tdefer.prototype.makeNodeResolver = function () {\n\t    var self = this;\n\t    return function (error, value) {\n\t        if (error) {\n\t            self.reject(error);\n\t        } else if (arguments.length > 2) {\n\t            self.resolve(array_slice(arguments, 1));\n\t        } else {\n\t            self.resolve(value);\n\t        }\n\t    };\n\t};\n\t\n\t/**\n\t * @param resolver {Function} a function that returns nothing and accepts\n\t * the resolve, reject, and notify functions for a deferred.\n\t * @returns a promise that may be resolved with the given resolve and reject\n\t * functions, or rejected by a thrown exception in resolver\n\t */\n\tQ.Promise = promise; // ES6\n\tQ.promise = promise;\n\tfunction promise(resolver) {\n\t    if (typeof resolver !== \"function\") {\n\t        throw new TypeError(\"resolver must be a function.\");\n\t    }\n\t    var deferred = defer();\n\t    try {\n\t        resolver(deferred.resolve, deferred.reject, deferred.notify);\n\t    } catch (reason) {\n\t        deferred.reject(reason);\n\t    }\n\t    return deferred.promise;\n\t}\n\t\n\tpromise.race = race; // ES6\n\tpromise.all = all; // ES6\n\tpromise.reject = reject; // ES6\n\tpromise.resolve = Q; // ES6\n\t\n\t// XXX experimental.  This method is a way to denote that a local value is\n\t// serializable and should be immediately dispatched to a remote upon request,\n\t// instead of passing a reference.\n\tQ.passByCopy = function (object) {\n\t    //freeze(object);\n\t    //passByCopies.set(object, true);\n\t    return object;\n\t};\n\t\n\tPromise.prototype.passByCopy = function () {\n\t    //freeze(object);\n\t    //passByCopies.set(object, true);\n\t    return this;\n\t};\n\t\n\t/**\n\t * If two promises eventually fulfill to the same value, promises that value,\n\t * but otherwise rejects.\n\t * @param x {Any*}\n\t * @param y {Any*}\n\t * @returns {Any*} a promise for x and y if they are the same, but a rejection\n\t * otherwise.\n\t *\n\t */\n\tQ.join = function (x, y) {\n\t    return Q(x).join(y);\n\t};\n\t\n\tPromise.prototype.join = function (that) {\n\t    return Q([this, that]).spread(function (x, y) {\n\t        if (x === y) {\n\t            // TODO: \"===\" should be Object.is or equiv\n\t            return x;\n\t        } else {\n\t            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n\t        }\n\t    });\n\t};\n\t\n\t/**\n\t * Returns a promise for the first of an array of promises to become settled.\n\t * @param answers {Array[Any*]} promises to race\n\t * @returns {Any*} the first promise to be settled\n\t */\n\tQ.race = race;\n\tfunction race(answerPs) {\n\t    return promise(function (resolve, reject) {\n\t        // Switch to this once we can assume at least ES5\n\t        // answerPs.forEach(function (answerP) {\n\t        //     Q(answerP).then(resolve, reject);\n\t        // });\n\t        // Use this in the meantime\n\t        for (var i = 0, len = answerPs.length; i < len; i++) {\n\t            Q(answerPs[i]).then(resolve, reject);\n\t        }\n\t    });\n\t}\n\t\n\tPromise.prototype.race = function () {\n\t    return this.then(Q.race);\n\t};\n\t\n\t/**\n\t * Constructs a Promise with a promise descriptor object and optional fallback\n\t * function.  The descriptor contains methods like when(rejected), get(name),\n\t * set(name, value), post(name, args), and delete(name), which all\n\t * return either a value, a promise for a value, or a rejection.  The fallback\n\t * accepts the operation name, a resolver, and any further arguments that would\n\t * have been forwarded to the appropriate method above had a method been\n\t * provided with the proper name.  The API makes no guarantees about the nature\n\t * of the returned object, apart from that it is usable whereever promises are\n\t * bought and sold.\n\t */\n\tQ.makePromise = Promise;\n\tfunction Promise(descriptor, fallback, inspect) {\n\t    if (fallback === void 0) {\n\t        fallback = function (op) {\n\t            return reject(new Error(\n\t                \"Promise does not support operation: \" + op\n\t            ));\n\t        };\n\t    }\n\t    if (inspect === void 0) {\n\t        inspect = function () {\n\t            return {state: \"unknown\"};\n\t        };\n\t    }\n\t\n\t    var promise = object_create(Promise.prototype);\n\t\n\t    promise.promiseDispatch = function (resolve, op, args) {\n\t        var result;\n\t        try {\n\t            if (descriptor[op]) {\n\t                result = descriptor[op].apply(promise, args);\n\t            } else {\n\t                result = fallback.call(promise, op, args);\n\t            }\n\t        } catch (exception) {\n\t            result = reject(exception);\n\t        }\n\t        if (resolve) {\n\t            resolve(result);\n\t        }\n\t    };\n\t\n\t    promise.inspect = inspect;\n\t\n\t    // XXX deprecated `valueOf` and `exception` support\n\t    if (inspect) {\n\t        var inspected = inspect();\n\t        if (inspected.state === \"rejected\") {\n\t            promise.exception = inspected.reason;\n\t        }\n\t\n\t        promise.valueOf = function () {\n\t            var inspected = inspect();\n\t            if (inspected.state === \"pending\" ||\n\t                inspected.state === \"rejected\") {\n\t                return promise;\n\t            }\n\t            return inspected.value;\n\t        };\n\t    }\n\t\n\t    return promise;\n\t}\n\t\n\tPromise.prototype.toString = function () {\n\t    return \"[object Promise]\";\n\t};\n\t\n\tPromise.prototype.then = function (fulfilled, rejected, progressed) {\n\t    var self = this;\n\t    var deferred = defer();\n\t    var done = false;   // ensure the untrusted promise makes at most a\n\t                        // single call to one of the callbacks\n\t\n\t    function _fulfilled(value) {\n\t        try {\n\t            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n\t        } catch (exception) {\n\t            return reject(exception);\n\t        }\n\t    }\n\t\n\t    function _rejected(exception) {\n\t        if (typeof rejected === \"function\") {\n\t            makeStackTraceLong(exception, self);\n\t            try {\n\t                return rejected(exception);\n\t            } catch (newException) {\n\t                return reject(newException);\n\t            }\n\t        }\n\t        return reject(exception);\n\t    }\n\t\n\t    function _progressed(value) {\n\t        return typeof progressed === \"function\" ? progressed(value) : value;\n\t    }\n\t\n\t    Q.nextTick(function () {\n\t        self.promiseDispatch(function (value) {\n\t            if (done) {\n\t                return;\n\t            }\n\t            done = true;\n\t\n\t            deferred.resolve(_fulfilled(value));\n\t        }, \"when\", [function (exception) {\n\t            if (done) {\n\t                return;\n\t            }\n\t            done = true;\n\t\n\t            deferred.resolve(_rejected(exception));\n\t        }]);\n\t    });\n\t\n\t    // Progress propagator need to be attached in the current tick.\n\t    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n\t        var newValue;\n\t        var threw = false;\n\t        try {\n\t            newValue = _progressed(value);\n\t        } catch (e) {\n\t            threw = true;\n\t            if (Q.onerror) {\n\t                Q.onerror(e);\n\t            } else {\n\t                throw e;\n\t            }\n\t        }\n\t\n\t        if (!threw) {\n\t            deferred.notify(newValue);\n\t        }\n\t    }]);\n\t\n\t    return deferred.promise;\n\t};\n\t\n\tQ.tap = function (promise, callback) {\n\t    return Q(promise).tap(callback);\n\t};\n\t\n\t/**\n\t * Works almost like \"finally\", but not called for rejections.\n\t * Original resolution value is passed through callback unaffected.\n\t * Callback may return a promise that will be awaited for.\n\t * @param {Function} callback\n\t * @returns {Q.Promise}\n\t * @example\n\t * doSomething()\n\t *   .then(...)\n\t *   .tap(console.log)\n\t *   .then(...);\n\t */\n\tPromise.prototype.tap = function (callback) {\n\t    callback = Q(callback);\n\t\n\t    return this.then(function (value) {\n\t        return callback.fcall(value).thenResolve(value);\n\t    });\n\t};\n\t\n\t/**\n\t * Registers an observer on a promise.\n\t *\n\t * Guarantees:\n\t *\n\t * 1. that fulfilled and rejected will be called only once.\n\t * 2. that either the fulfilled callback or the rejected callback will be\n\t *    called, but not both.\n\t * 3. that fulfilled and rejected will not be called in this turn.\n\t *\n\t * @param value      promise or immediate reference to observe\n\t * @param fulfilled  function to be called with the fulfilled value\n\t * @param rejected   function to be called with the rejection exception\n\t * @param progressed function to be called on any progress notifications\n\t * @return promise for the return value from the invoked callback\n\t */\n\tQ.when = when;\n\tfunction when(value, fulfilled, rejected, progressed) {\n\t    return Q(value).then(fulfilled, rejected, progressed);\n\t}\n\t\n\tPromise.prototype.thenResolve = function (value) {\n\t    return this.then(function () { return value; });\n\t};\n\t\n\tQ.thenResolve = function (promise, value) {\n\t    return Q(promise).thenResolve(value);\n\t};\n\t\n\tPromise.prototype.thenReject = function (reason) {\n\t    return this.then(function () { throw reason; });\n\t};\n\t\n\tQ.thenReject = function (promise, reason) {\n\t    return Q(promise).thenReject(reason);\n\t};\n\t\n\t/**\n\t * If an object is not a promise, it is as \"near\" as possible.\n\t * If a promise is rejected, it is as \"near\" as possible too.\n\t * If its a fulfilled promise, the fulfillment value is nearer.\n\t * If its a deferred promise and the deferred has been resolved, the\n\t * resolution is \"nearer\".\n\t * @param object\n\t * @returns most resolved (nearest) form of the object\n\t */\n\t\n\t// XXX should we re-do this?\n\tQ.nearer = nearer;\n\tfunction nearer(value) {\n\t    if (isPromise(value)) {\n\t        var inspected = value.inspect();\n\t        if (inspected.state === \"fulfilled\") {\n\t            return inspected.value;\n\t        }\n\t    }\n\t    return value;\n\t}\n\t\n\t/**\n\t * @returns whether the given object is a promise.\n\t * Otherwise it is a fulfilled value.\n\t */\n\tQ.isPromise = isPromise;\n\tfunction isPromise(object) {\n\t    return object instanceof Promise;\n\t}\n\t\n\tQ.isPromiseAlike = isPromiseAlike;\n\tfunction isPromiseAlike(object) {\n\t    return isObject(object) && typeof object.then === \"function\";\n\t}\n\t\n\t/**\n\t * @returns whether the given object is a pending promise, meaning not\n\t * fulfilled or rejected.\n\t */\n\tQ.isPending = isPending;\n\tfunction isPending(object) {\n\t    return isPromise(object) && object.inspect().state === \"pending\";\n\t}\n\t\n\tPromise.prototype.isPending = function () {\n\t    return this.inspect().state === \"pending\";\n\t};\n\t\n\t/**\n\t * @returns whether the given object is a value or fulfilled\n\t * promise.\n\t */\n\tQ.isFulfilled = isFulfilled;\n\tfunction isFulfilled(object) {\n\t    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n\t}\n\t\n\tPromise.prototype.isFulfilled = function () {\n\t    return this.inspect().state === \"fulfilled\";\n\t};\n\t\n\t/**\n\t * @returns whether the given object is a rejected promise.\n\t */\n\tQ.isRejected = isRejected;\n\tfunction isRejected(object) {\n\t    return isPromise(object) && object.inspect().state === \"rejected\";\n\t}\n\t\n\tPromise.prototype.isRejected = function () {\n\t    return this.inspect().state === \"rejected\";\n\t};\n\t\n\t//// BEGIN UNHANDLED REJECTION TRACKING\n\t\n\t// This promise library consumes exceptions thrown in handlers so they can be\n\t// handled by a subsequent promise.  The exceptions get added to this array when\n\t// they are created, and removed when they are handled.  Note that in ES6 or\n\t// shimmed environments, this would naturally be a `Set`.\n\tvar unhandledReasons = [];\n\tvar unhandledRejections = [];\n\tvar reportedUnhandledRejections = [];\n\tvar trackUnhandledRejections = true;\n\t\n\tfunction resetUnhandledRejections() {\n\t    unhandledReasons.length = 0;\n\t    unhandledRejections.length = 0;\n\t\n\t    if (!trackUnhandledRejections) {\n\t        trackUnhandledRejections = true;\n\t    }\n\t}\n\t\n\tfunction trackRejection(promise, reason) {\n\t    if (!trackUnhandledRejections) {\n\t        return;\n\t    }\n\t    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n\t        Q.nextTick.runAfter(function () {\n\t            if (array_indexOf(unhandledRejections, promise) !== -1) {\n\t                process.emit(\"unhandledRejection\", reason, promise);\n\t                reportedUnhandledRejections.push(promise);\n\t            }\n\t        });\n\t    }\n\t\n\t    unhandledRejections.push(promise);\n\t    if (reason && typeof reason.stack !== \"undefined\") {\n\t        unhandledReasons.push(reason.stack);\n\t    } else {\n\t        unhandledReasons.push(\"(no stack) \" + reason);\n\t    }\n\t}\n\t\n\tfunction untrackRejection(promise) {\n\t    if (!trackUnhandledRejections) {\n\t        return;\n\t    }\n\t\n\t    var at = array_indexOf(unhandledRejections, promise);\n\t    if (at !== -1) {\n\t        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n\t            Q.nextTick.runAfter(function () {\n\t                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n\t                if (atReport !== -1) {\n\t                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n\t                    reportedUnhandledRejections.splice(atReport, 1);\n\t                }\n\t            });\n\t        }\n\t        unhandledRejections.splice(at, 1);\n\t        unhandledReasons.splice(at, 1);\n\t    }\n\t}\n\t\n\tQ.resetUnhandledRejections = resetUnhandledRejections;\n\t\n\tQ.getUnhandledReasons = function () {\n\t    // Make a copy so that consumers can't interfere with our internal state.\n\t    return unhandledReasons.slice();\n\t};\n\t\n\tQ.stopUnhandledRejectionTracking = function () {\n\t    resetUnhandledRejections();\n\t    trackUnhandledRejections = false;\n\t};\n\t\n\tresetUnhandledRejections();\n\t\n\t//// END UNHANDLED REJECTION TRACKING\n\t\n\t/**\n\t * Constructs a rejected promise.\n\t * @param reason value describing the failure\n\t */\n\tQ.reject = reject;\n\tfunction reject(reason) {\n\t    var rejection = Promise({\n\t        \"when\": function (rejected) {\n\t            // note that the error has been handled\n\t            if (rejected) {\n\t                untrackRejection(this);\n\t            }\n\t            return rejected ? rejected(reason) : this;\n\t        }\n\t    }, function fallback() {\n\t        return this;\n\t    }, function inspect() {\n\t        return { state: \"rejected\", reason: reason };\n\t    });\n\t\n\t    // Note that the reason has not been handled.\n\t    trackRejection(rejection, reason);\n\t\n\t    return rejection;\n\t}\n\t\n\t/**\n\t * Constructs a fulfilled promise for an immediate reference.\n\t * @param value immediate reference\n\t */\n\tQ.fulfill = fulfill;\n\tfunction fulfill(value) {\n\t    return Promise({\n\t        \"when\": function () {\n\t            return value;\n\t        },\n\t        \"get\": function (name) {\n\t            return value[name];\n\t        },\n\t        \"set\": function (name, rhs) {\n\t            value[name] = rhs;\n\t        },\n\t        \"delete\": function (name) {\n\t            delete value[name];\n\t        },\n\t        \"post\": function (name, args) {\n\t            // Mark Miller proposes that post with no name should apply a\n\t            // promised function.\n\t            if (name === null || name === void 0) {\n\t                return value.apply(void 0, args);\n\t            } else {\n\t                return value[name].apply(value, args);\n\t            }\n\t        },\n\t        \"apply\": function (thisp, args) {\n\t            return value.apply(thisp, args);\n\t        },\n\t        \"keys\": function () {\n\t            return object_keys(value);\n\t        }\n\t    }, void 0, function inspect() {\n\t        return { state: \"fulfilled\", value: value };\n\t    });\n\t}\n\t\n\t/**\n\t * Converts thenables to Q promises.\n\t * @param promise thenable promise\n\t * @returns a Q promise\n\t */\n\tfunction coerce(promise) {\n\t    var deferred = defer();\n\t    Q.nextTick(function () {\n\t        try {\n\t            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n\t        } catch (exception) {\n\t            deferred.reject(exception);\n\t        }\n\t    });\n\t    return deferred.promise;\n\t}\n\t\n\t/**\n\t * Annotates an object such that it will never be\n\t * transferred away from this process over any promise\n\t * communication channel.\n\t * @param object\n\t * @returns promise a wrapping of that object that\n\t * additionally responds to the \"isDef\" message\n\t * without a rejection.\n\t */\n\tQ.master = master;\n\tfunction master(object) {\n\t    return Promise({\n\t        \"isDef\": function () {}\n\t    }, function fallback(op, args) {\n\t        return dispatch(object, op, args);\n\t    }, function () {\n\t        return Q(object).inspect();\n\t    });\n\t}\n\t\n\t/**\n\t * Spreads the values of a promised array of arguments into the\n\t * fulfillment callback.\n\t * @param fulfilled callback that receives variadic arguments from the\n\t * promised array\n\t * @param rejected callback that receives the exception if the promise\n\t * is rejected.\n\t * @returns a promise for the return value or thrown exception of\n\t * either callback.\n\t */\n\tQ.spread = spread;\n\tfunction spread(value, fulfilled, rejected) {\n\t    return Q(value).spread(fulfilled, rejected);\n\t}\n\t\n\tPromise.prototype.spread = function (fulfilled, rejected) {\n\t    return this.all().then(function (array) {\n\t        return fulfilled.apply(void 0, array);\n\t    }, rejected);\n\t};\n\t\n\t/**\n\t * The async function is a decorator for generator functions, turning\n\t * them into asynchronous generators.  Although generators are only part\n\t * of the newest ECMAScript 6 drafts, this code does not cause syntax\n\t * errors in older engines.  This code should continue to work and will\n\t * in fact improve over time as the language improves.\n\t *\n\t * ES6 generators are currently part of V8 version 3.19 with the\n\t * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n\t * for longer, but under an older Python-inspired form.  This function\n\t * works on both kinds of generators.\n\t *\n\t * Decorates a generator function such that:\n\t *  - it may yield promises\n\t *  - execution will continue when that promise is fulfilled\n\t *  - the value of the yield expression will be the fulfilled value\n\t *  - it returns a promise for the return value (when the generator\n\t *    stops iterating)\n\t *  - the decorated function returns a promise for the return value\n\t *    of the generator or the first rejected promise among those\n\t *    yielded.\n\t *  - if an error is thrown in the generator, it propagates through\n\t *    every following yield until it is caught, or until it escapes\n\t *    the generator function altogether, and is translated into a\n\t *    rejection for the promise returned by the decorated generator.\n\t */\n\tQ.async = async;\n\tfunction async(makeGenerator) {\n\t    return function () {\n\t        // when verb is \"send\", arg is a value\n\t        // when verb is \"throw\", arg is an exception\n\t        function continuer(verb, arg) {\n\t            var result;\n\t\n\t            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n\t            // engine that has a deployed base of browsers that support generators.\n\t            // However, SM's generators use the Python-inspired semantics of\n\t            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n\t            // like to make it possible to use generators in deployed browsers, so\n\t            // we also support Python-style generators.  At some point we can remove\n\t            // this block.\n\t\n\t            if (typeof StopIteration === \"undefined\") {\n\t                // ES6 Generators\n\t                try {\n\t                    result = generator[verb](arg);\n\t                } catch (exception) {\n\t                    return reject(exception);\n\t                }\n\t                if (result.done) {\n\t                    return Q(result.value);\n\t                } else {\n\t                    return when(result.value, callback, errback);\n\t                }\n\t            } else {\n\t                // SpiderMonkey Generators\n\t                // FIXME: Remove this case when SM does ES6 generators.\n\t                try {\n\t                    result = generator[verb](arg);\n\t                } catch (exception) {\n\t                    if (isStopIteration(exception)) {\n\t                        return Q(exception.value);\n\t                    } else {\n\t                        return reject(exception);\n\t                    }\n\t                }\n\t                return when(result, callback, errback);\n\t            }\n\t        }\n\t        var generator = makeGenerator.apply(this, arguments);\n\t        var callback = continuer.bind(continuer, \"next\");\n\t        var errback = continuer.bind(continuer, \"throw\");\n\t        return callback();\n\t    };\n\t}\n\t\n\t/**\n\t * The spawn function is a small wrapper around async that immediately\n\t * calls the generator and also ends the promise chain, so that any\n\t * unhandled errors are thrown instead of forwarded to the error\n\t * handler. This is useful because it's extremely common to run\n\t * generators at the top-level to work with libraries.\n\t */\n\tQ.spawn = spawn;\n\tfunction spawn(makeGenerator) {\n\t    Q.done(Q.async(makeGenerator)());\n\t}\n\t\n\t// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n\t/**\n\t * Throws a ReturnValue exception to stop an asynchronous generator.\n\t *\n\t * This interface is a stop-gap measure to support generator return\n\t * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n\t * generators like Chromium 29, just use \"return\" in your generator\n\t * functions.\n\t *\n\t * @param value the return value for the surrounding generator\n\t * @throws ReturnValue exception with the value.\n\t * @example\n\t * // ES6 style\n\t * Q.async(function* () {\n\t *      var foo = yield getFooPromise();\n\t *      var bar = yield getBarPromise();\n\t *      return foo + bar;\n\t * })\n\t * // Older SpiderMonkey style\n\t * Q.async(function () {\n\t *      var foo = yield getFooPromise();\n\t *      var bar = yield getBarPromise();\n\t *      Q.return(foo + bar);\n\t * })\n\t */\n\tQ[\"return\"] = _return;\n\tfunction _return(value) {\n\t    throw new QReturnValue(value);\n\t}\n\t\n\t/**\n\t * The promised function decorator ensures that any promise arguments\n\t * are settled and passed as values (`this` is also settled and passed\n\t * as a value).  It will also ensure that the result of a function is\n\t * always a promise.\n\t *\n\t * @example\n\t * var add = Q.promised(function (a, b) {\n\t *     return a + b;\n\t * });\n\t * add(Q(a), Q(B));\n\t *\n\t * @param {function} callback The function to decorate\n\t * @returns {function} a function that has been decorated.\n\t */\n\tQ.promised = promised;\n\tfunction promised(callback) {\n\t    return function () {\n\t        return spread([this, all(arguments)], function (self, args) {\n\t            return callback.apply(self, args);\n\t        });\n\t    };\n\t}\n\t\n\t/**\n\t * sends a message to a value in a future turn\n\t * @param object* the recipient\n\t * @param op the name of the message operation, e.g., \"when\",\n\t * @param args further arguments to be forwarded to the operation\n\t * @returns result {Promise} a promise for the result of the operation\n\t */\n\tQ.dispatch = dispatch;\n\tfunction dispatch(object, op, args) {\n\t    return Q(object).dispatch(op, args);\n\t}\n\t\n\tPromise.prototype.dispatch = function (op, args) {\n\t    var self = this;\n\t    var deferred = defer();\n\t    Q.nextTick(function () {\n\t        self.promiseDispatch(deferred.resolve, op, args);\n\t    });\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Gets the value of a property in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of property to get\n\t * @return promise for the property value\n\t */\n\tQ.get = function (object, key) {\n\t    return Q(object).dispatch(\"get\", [key]);\n\t};\n\t\n\tPromise.prototype.get = function (key) {\n\t    return this.dispatch(\"get\", [key]);\n\t};\n\t\n\t/**\n\t * Sets the value of a property in a future turn.\n\t * @param object    promise or immediate reference for object object\n\t * @param name      name of property to set\n\t * @param value     new value of property\n\t * @return promise for the return value\n\t */\n\tQ.set = function (object, key, value) {\n\t    return Q(object).dispatch(\"set\", [key, value]);\n\t};\n\t\n\tPromise.prototype.set = function (key, value) {\n\t    return this.dispatch(\"set\", [key, value]);\n\t};\n\t\n\t/**\n\t * Deletes a property in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of property to delete\n\t * @return promise for the return value\n\t */\n\tQ.del = // XXX legacy\n\tQ[\"delete\"] = function (object, key) {\n\t    return Q(object).dispatch(\"delete\", [key]);\n\t};\n\t\n\tPromise.prototype.del = // XXX legacy\n\tPromise.prototype[\"delete\"] = function (key) {\n\t    return this.dispatch(\"delete\", [key]);\n\t};\n\t\n\t/**\n\t * Invokes a method in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of method to invoke\n\t * @param value     a value to post, typically an array of\n\t *                  invocation arguments for promises that\n\t *                  are ultimately backed with `resolve` values,\n\t *                  as opposed to those backed with URLs\n\t *                  wherein the posted value can be any\n\t *                  JSON serializable object.\n\t * @return promise for the return value\n\t */\n\t// bound locally because it is used by other methods\n\tQ.mapply = // XXX As proposed by \"Redsandro\"\n\tQ.post = function (object, name, args) {\n\t    return Q(object).dispatch(\"post\", [name, args]);\n\t};\n\t\n\tPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.post = function (name, args) {\n\t    return this.dispatch(\"post\", [name, args]);\n\t};\n\t\n\t/**\n\t * Invokes a method in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @param name      name of method to invoke\n\t * @param ...args   array of invocation arguments\n\t * @return promise for the return value\n\t */\n\tQ.send = // XXX Mark Miller's proposed parlance\n\tQ.mcall = // XXX As proposed by \"Redsandro\"\n\tQ.invoke = function (object, name /*...args*/) {\n\t    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n\t};\n\t\n\tPromise.prototype.send = // XXX Mark Miller's proposed parlance\n\tPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.invoke = function (name /*...args*/) {\n\t    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n\t};\n\t\n\t/**\n\t * Applies the promised function in a future turn.\n\t * @param object    promise or immediate reference for target function\n\t * @param args      array of application arguments\n\t */\n\tQ.fapply = function (object, args) {\n\t    return Q(object).dispatch(\"apply\", [void 0, args]);\n\t};\n\t\n\tPromise.prototype.fapply = function (args) {\n\t    return this.dispatch(\"apply\", [void 0, args]);\n\t};\n\t\n\t/**\n\t * Calls the promised function in a future turn.\n\t * @param object    promise or immediate reference for target function\n\t * @param ...args   array of application arguments\n\t */\n\tQ[\"try\"] =\n\tQ.fcall = function (object /* ...args*/) {\n\t    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n\t};\n\t\n\tPromise.prototype.fcall = function (/*...args*/) {\n\t    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n\t};\n\t\n\t/**\n\t * Binds the promised function, transforming return values into a fulfilled\n\t * promise and thrown errors into a rejected one.\n\t * @param object    promise or immediate reference for target function\n\t * @param ...args   array of application arguments\n\t */\n\tQ.fbind = function (object /*...args*/) {\n\t    var promise = Q(object);\n\t    var args = array_slice(arguments, 1);\n\t    return function fbound() {\n\t        return promise.dispatch(\"apply\", [\n\t            this,\n\t            args.concat(array_slice(arguments))\n\t        ]);\n\t    };\n\t};\n\tPromise.prototype.fbind = function (/*...args*/) {\n\t    var promise = this;\n\t    var args = array_slice(arguments);\n\t    return function fbound() {\n\t        return promise.dispatch(\"apply\", [\n\t            this,\n\t            args.concat(array_slice(arguments))\n\t        ]);\n\t    };\n\t};\n\t\n\t/**\n\t * Requests the names of the owned properties of a promised\n\t * object in a future turn.\n\t * @param object    promise or immediate reference for target object\n\t * @return promise for the keys of the eventually settled object\n\t */\n\tQ.keys = function (object) {\n\t    return Q(object).dispatch(\"keys\", []);\n\t};\n\t\n\tPromise.prototype.keys = function () {\n\t    return this.dispatch(\"keys\", []);\n\t};\n\t\n\t/**\n\t * Turns an array of promises into a promise for an array.  If any of\n\t * the promises gets rejected, the whole array is rejected immediately.\n\t * @param {Array*} an array (or promise for an array) of values (or\n\t * promises for values)\n\t * @returns a promise for an array of the corresponding values\n\t */\n\t// By Mark Miller\n\t// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n\tQ.all = all;\n\tfunction all(promises) {\n\t    return when(promises, function (promises) {\n\t        var pendingCount = 0;\n\t        var deferred = defer();\n\t        array_reduce(promises, function (undefined, promise, index) {\n\t            var snapshot;\n\t            if (\n\t                isPromise(promise) &&\n\t                (snapshot = promise.inspect()).state === \"fulfilled\"\n\t            ) {\n\t                promises[index] = snapshot.value;\n\t            } else {\n\t                ++pendingCount;\n\t                when(\n\t                    promise,\n\t                    function (value) {\n\t                        promises[index] = value;\n\t                        if (--pendingCount === 0) {\n\t                            deferred.resolve(promises);\n\t                        }\n\t                    },\n\t                    deferred.reject,\n\t                    function (progress) {\n\t                        deferred.notify({ index: index, value: progress });\n\t                    }\n\t                );\n\t            }\n\t        }, void 0);\n\t        if (pendingCount === 0) {\n\t            deferred.resolve(promises);\n\t        }\n\t        return deferred.promise;\n\t    });\n\t}\n\t\n\tPromise.prototype.all = function () {\n\t    return all(this);\n\t};\n\t\n\t/**\n\t * Returns the first resolved promise of an array. Prior rejected promises are\n\t * ignored.  Rejects only if all promises are rejected.\n\t * @param {Array*} an array containing values or promises for values\n\t * @returns a promise fulfilled with the value of the first resolved promise,\n\t * or a rejected promise if all promises are rejected.\n\t */\n\tQ.any = any;\n\t\n\tfunction any(promises) {\n\t    if (promises.length === 0) {\n\t        return Q.resolve();\n\t    }\n\t\n\t    var deferred = Q.defer();\n\t    var pendingCount = 0;\n\t    array_reduce(promises, function (prev, current, index) {\n\t        var promise = promises[index];\n\t\n\t        pendingCount++;\n\t\n\t        when(promise, onFulfilled, onRejected, onProgress);\n\t        function onFulfilled(result) {\n\t            deferred.resolve(result);\n\t        }\n\t        function onRejected() {\n\t            pendingCount--;\n\t            if (pendingCount === 0) {\n\t                deferred.reject(new Error(\n\t                    \"Can't get fulfillment value from any promise, all \" +\n\t                    \"promises were rejected.\"\n\t                ));\n\t            }\n\t        }\n\t        function onProgress(progress) {\n\t            deferred.notify({\n\t                index: index,\n\t                value: progress\n\t            });\n\t        }\n\t    }, undefined);\n\t\n\t    return deferred.promise;\n\t}\n\t\n\tPromise.prototype.any = function () {\n\t    return any(this);\n\t};\n\t\n\t/**\n\t * Waits for all promises to be settled, either fulfilled or\n\t * rejected.  This is distinct from `all` since that would stop\n\t * waiting at the first rejection.  The promise returned by\n\t * `allResolved` will never be rejected.\n\t * @param promises a promise for an array (or an array) of promises\n\t * (or values)\n\t * @return a promise for an array of promises\n\t */\n\tQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\n\tfunction allResolved(promises) {\n\t    return when(promises, function (promises) {\n\t        promises = array_map(promises, Q);\n\t        return when(all(array_map(promises, function (promise) {\n\t            return when(promise, noop, noop);\n\t        })), function () {\n\t            return promises;\n\t        });\n\t    });\n\t}\n\t\n\tPromise.prototype.allResolved = function () {\n\t    return allResolved(this);\n\t};\n\t\n\t/**\n\t * @see Promise#allSettled\n\t */\n\tQ.allSettled = allSettled;\n\tfunction allSettled(promises) {\n\t    return Q(promises).allSettled();\n\t}\n\t\n\t/**\n\t * Turns an array of promises into a promise for an array of their states (as\n\t * returned by `inspect`) when they have all settled.\n\t * @param {Array[Any*]} values an array (or promise for an array) of values (or\n\t * promises for values)\n\t * @returns {Array[State]} an array of states for the respective values.\n\t */\n\tPromise.prototype.allSettled = function () {\n\t    return this.then(function (promises) {\n\t        return all(array_map(promises, function (promise) {\n\t            promise = Q(promise);\n\t            function regardless() {\n\t                return promise.inspect();\n\t            }\n\t            return promise.then(regardless, regardless);\n\t        }));\n\t    });\n\t};\n\t\n\t/**\n\t * Captures the failure of a promise, giving an oportunity to recover\n\t * with a callback.  If the given promise is fulfilled, the returned\n\t * promise is fulfilled.\n\t * @param {Any*} promise for something\n\t * @param {Function} callback to fulfill the returned promise if the\n\t * given promise is rejected\n\t * @returns a promise for the return value of the callback\n\t */\n\tQ.fail = // XXX legacy\n\tQ[\"catch\"] = function (object, rejected) {\n\t    return Q(object).then(void 0, rejected);\n\t};\n\t\n\tPromise.prototype.fail = // XXX legacy\n\tPromise.prototype[\"catch\"] = function (rejected) {\n\t    return this.then(void 0, rejected);\n\t};\n\t\n\t/**\n\t * Attaches a listener that can respond to progress notifications from a\n\t * promise's originating deferred. This listener receives the exact arguments\n\t * passed to ``deferred.notify``.\n\t * @param {Any*} promise for something\n\t * @param {Function} callback to receive any progress notifications\n\t * @returns the given promise, unchanged\n\t */\n\tQ.progress = progress;\n\tfunction progress(object, progressed) {\n\t    return Q(object).then(void 0, void 0, progressed);\n\t}\n\t\n\tPromise.prototype.progress = function (progressed) {\n\t    return this.then(void 0, void 0, progressed);\n\t};\n\t\n\t/**\n\t * Provides an opportunity to observe the settling of a promise,\n\t * regardless of whether the promise is fulfilled or rejected.  Forwards\n\t * the resolution to the returned promise when the callback is done.\n\t * The callback can return a promise to defer completion.\n\t * @param {Any*} promise\n\t * @param {Function} callback to observe the resolution of the given\n\t * promise, takes no arguments.\n\t * @returns a promise for the resolution of the given promise when\n\t * ``fin`` is done.\n\t */\n\tQ.fin = // XXX legacy\n\tQ[\"finally\"] = function (object, callback) {\n\t    return Q(object)[\"finally\"](callback);\n\t};\n\t\n\tPromise.prototype.fin = // XXX legacy\n\tPromise.prototype[\"finally\"] = function (callback) {\n\t    callback = Q(callback);\n\t    return this.then(function (value) {\n\t        return callback.fcall().then(function () {\n\t            return value;\n\t        });\n\t    }, function (reason) {\n\t        // TODO attempt to recycle the rejection with \"this\".\n\t        return callback.fcall().then(function () {\n\t            throw reason;\n\t        });\n\t    });\n\t};\n\t\n\t/**\n\t * Terminates a chain of promises, forcing rejections to be\n\t * thrown as exceptions.\n\t * @param {Any*} promise at the end of a chain of promises\n\t * @returns nothing\n\t */\n\tQ.done = function (object, fulfilled, rejected, progress) {\n\t    return Q(object).done(fulfilled, rejected, progress);\n\t};\n\t\n\tPromise.prototype.done = function (fulfilled, rejected, progress) {\n\t    var onUnhandledError = function (error) {\n\t        // forward to a future turn so that ``when``\n\t        // does not catch it and turn it into a rejection.\n\t        Q.nextTick(function () {\n\t            makeStackTraceLong(error, promise);\n\t            if (Q.onerror) {\n\t                Q.onerror(error);\n\t            } else {\n\t                throw error;\n\t            }\n\t        });\n\t    };\n\t\n\t    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n\t    var promise = fulfilled || rejected || progress ?\n\t        this.then(fulfilled, rejected, progress) :\n\t        this;\n\t\n\t    if (typeof process === \"object\" && process && process.domain) {\n\t        onUnhandledError = process.domain.bind(onUnhandledError);\n\t    }\n\t\n\t    promise.then(void 0, onUnhandledError);\n\t};\n\t\n\t/**\n\t * Causes a promise to be rejected if it does not get fulfilled before\n\t * some milliseconds time out.\n\t * @param {Any*} promise\n\t * @param {Number} milliseconds timeout\n\t * @param {Any*} custom error message or Error object (optional)\n\t * @returns a promise for the resolution of the given promise if it is\n\t * fulfilled before the timeout, otherwise rejected.\n\t */\n\tQ.timeout = function (object, ms, error) {\n\t    return Q(object).timeout(ms, error);\n\t};\n\t\n\tPromise.prototype.timeout = function (ms, error) {\n\t    var deferred = defer();\n\t    var timeoutId = setTimeout(function () {\n\t        if (!error || \"string\" === typeof error) {\n\t            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n\t            error.code = \"ETIMEDOUT\";\n\t        }\n\t        deferred.reject(error);\n\t    }, ms);\n\t\n\t    this.then(function (value) {\n\t        clearTimeout(timeoutId);\n\t        deferred.resolve(value);\n\t    }, function (exception) {\n\t        clearTimeout(timeoutId);\n\t        deferred.reject(exception);\n\t    }, deferred.notify);\n\t\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Returns a promise for the given value (or promised value), some\n\t * milliseconds after it resolved. Passes rejections immediately.\n\t * @param {Any*} promise\n\t * @param {Number} milliseconds\n\t * @returns a promise for the resolution of the given promise after milliseconds\n\t * time has elapsed since the resolution of the given promise.\n\t * If the given promise rejects, that is passed immediately.\n\t */\n\tQ.delay = function (object, timeout) {\n\t    if (timeout === void 0) {\n\t        timeout = object;\n\t        object = void 0;\n\t    }\n\t    return Q(object).delay(timeout);\n\t};\n\t\n\tPromise.prototype.delay = function (timeout) {\n\t    return this.then(function (value) {\n\t        var deferred = defer();\n\t        setTimeout(function () {\n\t            deferred.resolve(value);\n\t        }, timeout);\n\t        return deferred.promise;\n\t    });\n\t};\n\t\n\t/**\n\t * Passes a continuation to a Node function, which is called with the given\n\t * arguments provided as an array, and returns a promise.\n\t *\n\t *      Q.nfapply(FS.readFile, [__filename])\n\t *      .then(function (content) {\n\t *      })\n\t *\n\t */\n\tQ.nfapply = function (callback, args) {\n\t    return Q(callback).nfapply(args);\n\t};\n\t\n\tPromise.prototype.nfapply = function (args) {\n\t    var deferred = defer();\n\t    var nodeArgs = array_slice(args);\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.fapply(nodeArgs).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Passes a continuation to a Node function, which is called with the given\n\t * arguments provided individually, and returns a promise.\n\t * @example\n\t * Q.nfcall(FS.readFile, __filename)\n\t * .then(function (content) {\n\t * })\n\t *\n\t */\n\tQ.nfcall = function (callback /*...args*/) {\n\t    var args = array_slice(arguments, 1);\n\t    return Q(callback).nfapply(args);\n\t};\n\t\n\tPromise.prototype.nfcall = function (/*...args*/) {\n\t    var nodeArgs = array_slice(arguments);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.fapply(nodeArgs).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Wraps a NodeJS continuation passing function and returns an equivalent\n\t * version that returns a promise.\n\t * @example\n\t * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n\t * .then(console.log)\n\t * .done()\n\t */\n\tQ.nfbind =\n\tQ.denodeify = function (callback /*...args*/) {\n\t    var baseArgs = array_slice(arguments, 1);\n\t    return function () {\n\t        var nodeArgs = baseArgs.concat(array_slice(arguments));\n\t        var deferred = defer();\n\t        nodeArgs.push(deferred.makeNodeResolver());\n\t        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n\t        return deferred.promise;\n\t    };\n\t};\n\t\n\tPromise.prototype.nfbind =\n\tPromise.prototype.denodeify = function (/*...args*/) {\n\t    var args = array_slice(arguments);\n\t    args.unshift(this);\n\t    return Q.denodeify.apply(void 0, args);\n\t};\n\t\n\tQ.nbind = function (callback, thisp /*...args*/) {\n\t    var baseArgs = array_slice(arguments, 2);\n\t    return function () {\n\t        var nodeArgs = baseArgs.concat(array_slice(arguments));\n\t        var deferred = defer();\n\t        nodeArgs.push(deferred.makeNodeResolver());\n\t        function bound() {\n\t            return callback.apply(thisp, arguments);\n\t        }\n\t        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n\t        return deferred.promise;\n\t    };\n\t};\n\t\n\tPromise.prototype.nbind = function (/*thisp, ...args*/) {\n\t    var args = array_slice(arguments, 0);\n\t    args.unshift(this);\n\t    return Q.nbind.apply(void 0, args);\n\t};\n\t\n\t/**\n\t * Calls a method of a Node-style object that accepts a Node-style\n\t * callback with a given array of arguments, plus a provided callback.\n\t * @param object an object that has the named method\n\t * @param {String} name name of the method of object\n\t * @param {Array} args arguments to pass to the method; the callback\n\t * will be provided by Q and appended to these arguments.\n\t * @returns a promise for the value or error\n\t */\n\tQ.nmapply = // XXX As proposed by \"Redsandro\"\n\tQ.npost = function (object, name, args) {\n\t    return Q(object).npost(name, args);\n\t};\n\t\n\tPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\n\tPromise.prototype.npost = function (name, args) {\n\t    var nodeArgs = array_slice(args || []);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * Calls a method of a Node-style object that accepts a Node-style\n\t * callback, forwarding the given variadic arguments, plus a provided\n\t * callback argument.\n\t * @param object an object that has the named method\n\t * @param {String} name name of the method of object\n\t * @param ...args arguments to pass to the method; the callback will\n\t * be provided by Q and appended to these arguments.\n\t * @returns a promise for the value or error\n\t */\n\tQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\n\tQ.nmcall = // XXX Based on \"Redsandro's\" proposal\n\tQ.ninvoke = function (object, name /*...args*/) {\n\t    var nodeArgs = array_slice(arguments, 2);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\tPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\n\tPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\n\tPromise.prototype.ninvoke = function (name /*...args*/) {\n\t    var nodeArgs = array_slice(arguments, 1);\n\t    var deferred = defer();\n\t    nodeArgs.push(deferred.makeNodeResolver());\n\t    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n\t    return deferred.promise;\n\t};\n\t\n\t/**\n\t * If a function would like to support both Node continuation-passing-style and\n\t * promise-returning-style, it can end its internal promise chain with\n\t * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n\t * elects to use a nodeback, the result will be sent there.  If they do not\n\t * pass a nodeback, they will receive the result promise.\n\t * @param object a result (or a promise for a result)\n\t * @param {Function} nodeback a Node.js-style callback\n\t * @returns either the promise or nothing\n\t */\n\tQ.nodeify = nodeify;\n\tfunction nodeify(object, nodeback) {\n\t    return Q(object).nodeify(nodeback);\n\t}\n\t\n\tPromise.prototype.nodeify = function (nodeback) {\n\t    if (nodeback) {\n\t        this.then(function (value) {\n\t            Q.nextTick(function () {\n\t                nodeback(null, value);\n\t            });\n\t        }, function (error) {\n\t            Q.nextTick(function () {\n\t                nodeback(error);\n\t            });\n\t        });\n\t    } else {\n\t        return this;\n\t    }\n\t};\n\t\n\tQ.noConflict = function() {\n\t    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n\t};\n\t\n\t// All code before this point will be filtered from stack traces.\n\tvar qEndingLine = captureLine();\n\t\n\treturn Q;\n\t\n\t});\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6), __webpack_require__(5).setImmediate))\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** webmo.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e36868dbfb8fc8baa2e0\n **/","module.exports = {\n  http: require('./lib/http'),\n  ws: require('./lib/ws')\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/","var qwest = require('qwest')\n\nvar Webmo = function Webmo (host) {\n  this.base = '//' + (host || 'webmo.local')\n  this.base += '/api'\n  qwest.base = this.base\n\n  this._stepAngle = 1.8\n}\n\nWebmo.prototype.getStatus = function getStatus () {\n  return qwest.get('/status')\n}\n\n/**\n * Webmo\n * PromiseWeb\n *\n * @param {number} [speed] - (/)\n * @returns {Promise}\n */\nWebmo.prototype.rotate = function rotate (speed) {\n  return qwest.post('/rotate/forever', {speed: speed})\n}\n\nWebmo.prototype.rotateTo = function rotateTo (position, absRange, speed) {\n  var args = {\n    degree: position,\n    absRange: absRange,\n    speed: speed,\n    absolute: true\n  }\n\n  return qwest.post('/rotate', args)\n}\n\n/**\n * Webmo\n * : \n * : \n * PromiseWeb\n * \n *\n * @param {number} [degree] - ()\n * @param {number} [speed] - (/)\n * @returns {Promise}\n */\nWebmo.prototype.rotateBy = function rotateBy (degree, speed) {\n  var args = {\n    degree: degree,\n    speed: speed\n  }\n\n  return qwest.post('/rotate', args)\n}\n\n// XXX: Later\nWebmo.prototype.rotateToHome = function rotateToHome () {\n  return qwest.post('/rotate/home', {})\n}\n\n/**\n * Webmo\n *\n * @param {boolean} [smooth] - \n * @param {boolean} [lock] - \n * @returns {Promise}\n */\nWebmo.prototype.stop = function stop (smooth, lock) {\n  smooth = smooth || false\n  lock = lock || false\n  return qwest.post('/stop', {smooth: smooth, lock: lock})\n}\n\n/**\n * Webmo\n * \n *\n * @returns {Promise}\n */\nWebmo.prototype.stopHard = function stopHard () {\n  return qwest.post('/stop', {smooth: false})\n}\n\n/**\n * Webmo\n * \n *\n * @returns {Promise}\n */\nWebmo.prototype.stopSoft = function stopSoft () {\n  return qwest.post('/stop', {smooth: true})\n}\n\n/**\n * Webmo\n * \n *\n * @returns {Promise}\n */\nWebmo.prototype.lockHard = function () {\n  return qwest.post('/stop', {smooth: false})\n}\n\n/**\n * Webmo\n * \n *\n * @returns {Promise}\n */\nWebmo.prototype.lockSoft = function () {\n  return qwest.post('/stop', {smooth: true})\n}\n\n// XXX: Later\nWebmo.prototype.resetHome = function resetHome () {\n  return qwest.post('/home/reset', {})\n}\n\n/**\n * ()\n *\n * @param {Number} [angle] - \n * @returns {Number} - \n */\nWebmo.prototype.angleToStep = function angleToStep (angle) {\n  return angle / this._stepAngle\n}\n\n/**\n * \n *\n * @param {Number} [step] - \n * @returns {Number} - \n */\nWebmo.prototype.stepToAngle = function stepToAngle (step) {\n  return step * this._stepAngle / 128 // XXX: microstep must be supplied\n}\n\n\n// XXX: Later\nWebmo.prototype.getSpeedPerSecondByStep = function getSpeedPerSecondByStep (step) {\n  return Math.pow(2, 28) * step / Math.pow(10, 9) * 250\n}\n\n// XXX: Later\nWebmo.prototype.getSpeedPerSecondByAngle = function getSpeedPerSecondByAngle (angle) {\n  return this.getSpeedPerSecondByStep(this.angleToStep(angle))\n}\n\nmodule.exports = Webmo\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/http.js\n ** module id = 1\n ** module chunks = 0\n **/","/*! qwest 4.1.1 (https://github.com/pyrsmk/qwest) */\r\n\r\nmodule.exports = function() {\r\n\r\n\tvar global = window || this,\r\n\t\tpinkyswear = require('pinkyswear'),\r\n\t\tjparam = require('jquery-param'),\r\n\t\t// Default response type for XDR in auto mode\r\n\t\tdefaultXdrResponseType = 'json',\r\n\t\t// Default data type\r\n\t\tdefaultDataType = 'post',\r\n\t\t// Variables for limit mechanism\r\n\t\tlimit = null,\r\n\t\trequests = 0,\r\n\t\trequest_stack = [],\r\n\t\t// Get XMLHttpRequest object\r\n\t\tgetXHR = global.XMLHttpRequest? function(){\r\n\t\t\treturn new global.XMLHttpRequest();\r\n\t\t}: function(){\r\n\t\t\treturn new ActiveXObject('Microsoft.XMLHTTP');\r\n\t\t},\r\n\t\t// Guess XHR version\r\n\t\txhr2 = (getXHR().responseType===''),\r\n\r\n\t// Core function\r\n\tqwest = function(method, url, data, options, before) {\r\n\t\t// Format\r\n\t\tmethod = method.toUpperCase();\r\n\t\tdata = data || null;\r\n\t\toptions = options || {};\r\n\r\n\t\t// Define variables\r\n\t\tvar nativeResponseParsing = false,\r\n\t\t\tcrossOrigin,\r\n\t\t\txhr,\r\n\t\t\txdr = false,\r\n\t\t\ttimeoutInterval,\r\n\t\t\taborted = false,\r\n\t\t\tattempts = 0,\r\n\t\t\theaders = {},\r\n\t\t\tmimeTypes = {\r\n\t\t\t\ttext: '*/*',\r\n\t\t\t\txml: 'text/xml',\r\n\t\t\t\tjson: 'application/json',\r\n\t\t\t\tpost: 'application/x-www-form-urlencoded'\r\n\t\t\t},\r\n\t\t\taccept = {\r\n\t\t\t\ttext: '*/*',\r\n\t\t\t\txml: 'application/xml; q=1.0, text/xml; q=0.8, */*; q=0.1',\r\n\t\t\t\tjson: 'application/json; q=1.0, text/*; q=0.8, */*; q=0.1'\r\n\t\t\t},\r\n\t\t\ti, j,\r\n\t\t\tserialized,\r\n\t\t\tresponse,\r\n\t\t\tsending = false,\r\n\t\t\tdelayed = false,\r\n\t\t\ttimeout_start,\r\n\r\n\t\t// Create the promise\r\n\t\tpromise = pinkyswear(function(pinky) {\r\n\t\t\tpinky.abort = function() {\r\n\t\t\t\tif(xhr) {\r\n\t\t\t\t\txhr.abort();\r\n\t\t\t\t\t--requests;\r\n\t\t\t\t\taborted = true;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tpinky.send = function() {\r\n\t\t\t\t// Prevent further send() calls\r\n\t\t\t\tif(sending) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t// Reached request limit, get out!\r\n\t\t\t\tif(requests == limit) {\r\n\t\t\t\t\trequest_stack.push(pinky);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t++requests;\r\n\t\t\t\tsending = true;\r\n\t\t\t\t// Start the chrono\r\n\t\t\t\ttimeout_start = new Date().getTime();\r\n\t\t\t\t// Get XHR object\r\n\t\t\t\txhr = getXHR();\r\n\t\t\t\tif(crossOrigin) {\r\n\t\t\t\t\tif(!('withCredentials' in xhr) && global.XDomainRequest) {\r\n\t\t\t\t\t\txhr = new XDomainRequest(); // CORS with IE8/9\r\n\t\t\t\t\t\txdr = true;\r\n\t\t\t\t\t\tif(method!='GET' && method!='POST') {\r\n\t\t\t\t\t\t\tmethod = 'POST';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Open connection\r\n\t\t\t\tif(xdr) {\r\n\t\t\t\t\txhr.open(method, url);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\txhr.open(method, url, options.async, options.user, options.password);\r\n\t\t\t\t\tif(xhr2 && options.async) {\r\n\t\t\t\t\t\txhr.withCredentials = options.withCredentials;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Set headers\r\n\t\t\t\tif(!xdr) {\r\n\t\t\t\t\tfor(var i in headers) {\r\n\t\t\t\t\t\tif(headers[i]) {\r\n\t\t\t\t\t\t\txhr.setRequestHeader(i, headers[i]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Verify if the response type is supported by the current browser\r\n\t\t\t\tif(xhr2 && options.responseType != 'document' && options.responseType!='auto') { // Don't verify for 'document' since we're using an internal routine\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\txhr.responseType = options.responseType;\r\n\t\t\t\t\t\tnativeResponseParsing = (xhr.responseType==options.responseType);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch(e){}\r\n\t\t\t\t}\r\n\t\t\t\t// Plug response handler\r\n\t\t\t\tif(xhr2 || xdr) {\r\n\t\t\t\t\txhr.onload = handleResponse;\r\n\t\t\t\t\txhr.onerror = handleError;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\txhr.onreadystatechange = function() {\r\n\t\t\t\t\t\tif(xhr.readyState == 4) {\r\n\t\t\t\t\t\t\thandleResponse();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\t// Override mime type to ensure the response is well parsed\r\n\t\t\t\tif(options.responseType != 'auto' && 'overrideMimeType' in xhr) {\r\n\t\t\t\t\txhr.overrideMimeType(mimeTypes[options.responseType]);\r\n\t\t\t\t}\r\n\t\t\t\t// Run 'before' callback\r\n\t\t\t\tif(before) {\r\n\t\t\t\t\tbefore(xhr);\r\n\t\t\t\t}\r\n\t\t\t\t// Send request\r\n\t\t\t\tif(xdr) {\r\n\t\t\t\t\t// http://cypressnorth.com/programming/internet-explorer-aborting-ajax-requests-fixed/\r\n\t\t\t\t\txhr.onprogress = function(){};\r\n\t\t\t\t\txhr.ontimeout = function(){};\r\n\t\t\t\t\txhr.onerror = function(){};\r\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/XDomainRequest\r\n\t\t\t\t\tsetTimeout(function() {\r\n\t\t\t\t\t\txhr.send(method != 'GET'? data : null);\r\n\t\t\t\t\t}, 0);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\txhr.send(method != 'GET' ? data : null);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\treturn pinky;\r\n\t\t}),\r\n\r\n\t\t// Handle the response\r\n\t\thandleResponse = function() {\r\n\t\t\t// Prepare\r\n\t\t\tvar i, responseType;\r\n\t\t\t--requests;\r\n\t\t\tsending = false;\r\n\t\t\t// Verify timeout state\r\n\t\t\t// --- https://stackoverflow.com/questions/7287706/ie-9-javascript-error-c00c023f\r\n\t\t\tif(new Date().getTime()-timeout_start >= options.timeout) {\r\n\t\t\t\tif(!options.attempts || ++attempts!=options.attempts) {\r\n\t\t\t\t\tpromise.send();\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tpromise(false, [new Error('Timeout ('+url+')'), xhr, response]);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// Launch next stacked request\r\n\t\t\tif(request_stack.length) {\r\n\t\t\t\trequest_stack.shift().send();\r\n\t\t\t}\r\n\t\t\t// Handle response\r\n\t\t\ttry{\r\n\t\t\t\t// Process response\r\n\t\t\t\tif(nativeResponseParsing && 'response' in xhr && xhr.response!==null) {\r\n\t\t\t\t\tresponse = xhr.response;\r\n\t\t\t\t}\r\n\t\t\t\telse if(options.responseType == 'document') {\r\n\t\t\t\t\tvar frame = document.createElement('iframe');\r\n\t\t\t\t\tframe.style.display = 'none';\r\n\t\t\t\t\tdocument.body.appendChild(frame);\r\n\t\t\t\t\tframe.contentDocument.open();\r\n\t\t\t\t\tframe.contentDocument.write(xhr.response);\r\n\t\t\t\t\tframe.contentDocument.close();\r\n\t\t\t\t\tresponse = frame.contentDocument;\r\n\t\t\t\t\tdocument.body.removeChild(frame);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t// Guess response type\r\n\t\t\t\t\tresponseType = options.responseType;\r\n\t\t\t\t\tif(responseType == 'auto') {\r\n\t\t\t\t\t\tif(xdr) {\r\n\t\t\t\t\t\t\tresponseType = defaultXdrResponseType;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tvar ct = xhr.getResponseHeader('Content-Type') || '';\r\n\t\t\t\t\t\t\tif(ct.indexOf(mimeTypes.json)>-1) {\r\n\t\t\t\t\t\t\t\tresponseType = 'json';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(ct.indexOf(mimeTypes.xml)>-1) {\r\n\t\t\t\t\t\t\t\tresponseType = 'xml';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tresponseType = 'text';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Handle response type\r\n\t\t\t\t\tswitch(responseType) {\r\n\t\t\t\t\t\tcase 'json':\r\n\t\t\t\t\t\t\tif(xhr.responseText.length) {\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\tif('JSON' in global) {\r\n\t\t\t\t\t\t\t\t\t\tresponse = JSON.parse(xhr.responseText);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\tresponse = eval('('+xhr.responseText+')');\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcatch(e) {\r\n\t\t\t\t\t\t\t\t\tthrow \"Error while parsing JSON body : \"+e;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'xml':\r\n\t\t\t\t\t\t\t// Based on jQuery's parseXML() function\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t// Standard\r\n\t\t\t\t\t\t\t\tif(global.DOMParser) {\r\n\t\t\t\t\t\t\t\t\tresponse = (new DOMParser()).parseFromString(xhr.responseText,'text/xml');\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// IE<9\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tresponse = new ActiveXObject('Microsoft.XMLDOM');\r\n\t\t\t\t\t\t\t\t\tresponse.async = 'false';\r\n\t\t\t\t\t\t\t\t\tresponse.loadXML(xhr.responseText);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch(e) {\r\n\t\t\t\t\t\t\t\tresponse = undefined;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(!response || !response.documentElement || response.getElementsByTagName('parsererror').length) {\r\n\t\t\t\t\t\t\t\tthrow 'Invalid XML';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tresponse = xhr.responseText;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Late status code verification to allow passing data when, per example, a 409 is returned\r\n\t\t\t\t// --- https://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\r\n\t\t\t\tif('status' in xhr && !/^2|1223/.test(xhr.status)) {\r\n\t\t\t\t\tthrow xhr.status+' ('+xhr.statusText+')';\r\n\t\t\t\t}\r\n\t\t\t\t// Fulfilled\r\n\t\t\t\tpromise(true, [xhr, response]);\r\n\t\t\t}\r\n\t\t\tcatch(e) {\r\n\t\t\t\t// Rejected\r\n\t\t\t\tpromise(false, [e, xhr, response]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Handle errors\r\n\t\thandleError = function(e) {\r\n\t\t\t--requests;\r\n\t\t\tpromise(false, [new Error('Connection aborted'), xhr, null]);\r\n\t\t};\r\n\r\n\t\t// Normalize options\r\n\t\toptions.async = 'async' in options?!!options.async:true;\r\n\t\toptions.cache = 'cache' in options?!!options.cache:false;\r\n\t\toptions.dataType = 'dataType' in options?options.dataType.toLowerCase():defaultDataType;\r\n\t\toptions.responseType = 'responseType' in options?options.responseType.toLowerCase():'auto';\r\n\t\toptions.user = options.user || '';\r\n\t\toptions.password = options.password || '';\r\n\t\toptions.withCredentials = !!options.withCredentials;\r\n\t\toptions.timeout = 'timeout' in options?parseInt(options.timeout,10):30000;\r\n\t\toptions.attempts = 'attempts' in options?parseInt(options.attempts,10):1;\r\n\r\n\t\t// Guess if we're dealing with a cross-origin request\r\n\t\ti = url.match(/\\/\\/(.+?)\\//);\r\n\t\tcrossOrigin = i && (i[1]?i[1]!=location.host:false);\r\n\r\n\t\t// Prepare data\r\n\t\tif('ArrayBuffer' in global && data instanceof ArrayBuffer) {\r\n\t\t\toptions.dataType = 'arraybuffer';\r\n\t\t}\r\n\t\telse if('Blob' in global && data instanceof Blob) {\r\n\t\t\toptions.dataType = 'blob';\r\n\t\t}\r\n\t\telse if('Document' in global && data instanceof Document) {\r\n\t\t\toptions.dataType = 'document';\r\n\t\t}\r\n\t\telse if('FormData' in global && data instanceof FormData) {\r\n\t\t\toptions.dataType = 'formdata';\r\n\t\t}\r\n\t\tswitch(options.dataType) {\r\n\t\t\tcase 'json':\r\n\t\t\t\tdata = (data !== null ? JSON.stringify(data) : data);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'post':\r\n\t\t\t\tdata = jparam(data);\r\n\t\t}\r\n\r\n\t\t// Prepare headers\r\n\t\tif(options.headers) {\r\n\t\t\tvar format = function(match,p1,p2) {\r\n\t\t\t\treturn p1 + p2.toUpperCase();\r\n\t\t\t};\r\n\t\t\tfor(i in options.headers) {\r\n\t\t\t\theaders[i.replace(/(^|-)([^-])/g,format)] = options.headers[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!('Content-Type' in headers) && method!='GET') {\r\n\t\t\tif(options.dataType in mimeTypes) {\r\n\t\t\t\tif(mimeTypes[options.dataType]) {\r\n\t\t\t\t\theaders['Content-Type'] = mimeTypes[options.dataType];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!headers.Accept) {\r\n\t\t\theaders.Accept = (options.responseType in accept)?accept[options.responseType]:'*/*';\r\n\t\t}\r\n\t\tif(!crossOrigin && !('X-Requested-With' in headers)) { // (that header breaks in legacy browsers with CORS)\r\n\t\t\theaders['X-Requested-With'] = 'XMLHttpRequest';\r\n\t\t}\r\n\t\tif(!options.cache && !('Cache-Control' in headers)) {\r\n\t\t\theaders['Cache-Control'] = 'no-cache';\r\n\t\t}\r\n\r\n\t\t// Prepare URL\r\n\t\tif(method == 'GET' && data && typeof data == 'string') {\r\n\t\t\turl += (/\\?/.test(url)?'&':'?') + data;\r\n\t\t}\r\n\r\n\t\t// Start the request\r\n\t\tif(options.async) {\r\n\t\t\tpromise.send();\r\n\t\t}\r\n\r\n\t\t// Return promise\r\n\t\treturn promise;\r\n\r\n\t};\r\n\t\r\n\t// Define external qwest object\r\n\tvar getNewPromise = function(q) {\r\n\t\t\t// Prepare\r\n\t\t\tvar promises = [],\r\n\t\t\t\tloading = 0,\r\n\t\t\t\tvalues = [];\r\n\t\t\t// Create a new promise to handle all requests\r\n\t\t\treturn pinkyswear(function(pinky) {\r\n\t\t\t\t// Basic request method\r\n\t\t\t\tvar createMethod = function(method) {\r\n\t\t\t\t\treturn function(url, data, options, before) {\r\n\t\t\t\t\t\t++loading;\r\n\t\t\t\t\t\tpromises.push(qwest(method, pinky.base + url, data, options, before).then(function(xhr, response) {\r\n\t\t\t\t\t\t\tvalues.push(arguments);\r\n\t\t\t\t\t\t\tif(!--loading) {\r\n\t\t\t\t\t\t\t\tpinky(true, values.length == 1 ? values[0] : [values]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, function() {\r\n\t\t\t\t\t\t\tpinky(false, arguments);\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\t\treturn pinky;\r\n\t\t\t\t\t};\r\n\t\t\t\t};\r\n\t\t\t\t// Define external API\r\n\t\t\t\tpinky.get = createMethod('GET');\r\n\t\t\t\tpinky.post = createMethod('POST');\r\n\t\t\t\tpinky.put = createMethod('PUT');\r\n\t\t\t\tpinky['delete'] = createMethod('DELETE');\r\n\t\t\t\tpinky['catch'] = function(f) {\r\n\t\t\t\t\treturn pinky.then(null, f);\r\n\t\t\t\t};\r\n\t\t\t\tpinky.map = function(type, url, data, options, before) {\r\n\t\t\t\t\treturn createMethod(type.toUpperCase()).call(this, url, data, options, before);\r\n\t\t\t\t};\r\n\t\t\t\tfor(var prop in q) {\r\n\t\t\t\t\tif(!(prop in pinky)) {\r\n\t\t\t\t\t\tpinky[prop] = q[prop];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tpinky.send = function() {\r\n\t\t\t\t\tfor(var i=0, j=promises.length; i<j; ++i) {\r\n\t\t\t\t\t\tpromises[i].send();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn pinky;\r\n\t\t\t\t};\r\n\t\t\t\tpinky.abort = function() {\r\n\t\t\t\t\tfor(var i=0, j=promises.length; i<j; ++i) {\r\n\t\t\t\t\t\tpromises[i].abort();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn pinky;\r\n\t\t\t\t};\r\n\t\t\t\treturn pinky;\r\n\t\t\t});\r\n\t\t},\r\n\t\tq = {\r\n\t\t\tbase: '',\r\n\t\t\tget: function() {\r\n\t\t\t\treturn getNewPromise(q).get.apply(this, arguments);\r\n\t\t\t},\r\n\t\t\tpost: function() {\r\n\t\t\t\treturn getNewPromise(q).post.apply(this, arguments);\r\n\t\t\t},\r\n\t\t\tput: function() {\r\n\t\t\t\treturn getNewPromise(q).put.apply(this, arguments);\r\n\t\t\t},\r\n\t\t\t'delete': function() {\r\n\t\t\t\treturn getNewPromise(q)['delete'].apply(this, arguments);\r\n\t\t\t},\r\n\t\t\tmap: function() {\r\n\t\t\t\treturn getNewPromise(q).map.apply(this, arguments);\r\n\t\t\t},\r\n\t\t\txhr2: xhr2,\r\n\t\t\tlimit: function(by) {\r\n\t\t\t\tlimit = by;\r\n\t\t\t\treturn q;\r\n\t\t\t},\r\n\t\t\tsetDefaultXdrResponseType: function(type) {\r\n\t\t\t\tdefaultXdrResponseType = type.toLowerCase();\r\n\t\t\t\treturn q;\r\n\t\t\t},\r\n\t\t\tsetDefaultDataType: function(type) {\r\n\t\t\t\tdefaultDataType = type.toLowerCase();\r\n\t\t\t\treturn q;\r\n\t\t\t},\r\n\t\t\tgetOpenRequests: function() {\r\n\t\t\t\treturn requests;\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\treturn q;\r\n\r\n}();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/qwest/src/qwest.js\n ** module id = 2\n ** module chunks = 0\n **/","/*\n * PinkySwear.js 2.2.2 - Minimalistic implementation of the Promises/A+ spec\n * \n * Public Domain. Use, modify and distribute it any way you like. No attribution required.\n *\n * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n *\n * PinkySwear is a very small implementation of the Promises/A+ specification. After compilation with the\n * Google Closure Compiler and gzipping it weighs less than 500 bytes. It is based on the implementation for \n * Minified.js and should be perfect for embedding. \n *\n *\n * PinkySwear has just three functions.\n *\n * To create a new promise in pending state, call pinkySwear():\n *         var promise = pinkySwear();\n *\n * The returned object has a Promises/A+ compatible then() implementation:\n *          promise.then(function(value) { alert(\"Success!\"); }, function(value) { alert(\"Failure!\"); });\n *\n *\n * The promise returned by pinkySwear() is a function. To fulfill the promise, call the function with true as first argument and\n * an optional array of values to pass to the then() handler. By putting more than one value in the array, you can pass more than one\n * value to the then() handlers. Here an example to fulfill a promsise, this time with only one argument: \n *         promise(true, [42]);\n *\n * When the promise has been rejected, call it with false. Again, there may be more than one argument for the then() handler:\n *         promise(true, [6, 6, 6]);\n *         \n * You can obtain the promise's current state by calling the function without arguments. It will be true if fulfilled,\n * false if rejected, and otherwise undefined.\n * \t\t   var state = promise(); \n * \n * https://github.com/timjansen/PinkySwear.js\n */\n(function(target) {\n\tvar undef;\n\n\tfunction isFunction(f) {\n\t\treturn typeof f == 'function';\n\t}\n\tfunction isObject(f) {\n\t\treturn typeof f == 'object';\n\t}\n\tfunction defer(callback) {\n\t\tif (typeof setImmediate != 'undefined')\n\t\t\tsetImmediate(callback);\n\t\telse if (typeof process != 'undefined' && process['nextTick'])\n\t\t\tprocess['nextTick'](callback);\n\t\telse\n\t\t\tsetTimeout(callback, 0);\n\t}\n\n\ttarget[0][target[1]] = function pinkySwear(extend) {\n\t\tvar state;           // undefined/null = pending, true = fulfilled, false = rejected\n\t\tvar values = [];     // an array of values as arguments for the then() handlers\n\t\tvar deferred = [];   // functions to call when set() is invoked\n\n\t\tvar set = function(newState, newValues) {\n\t\t\tif (state == null && newState != null) {\n\t\t\t\tstate = newState;\n\t\t\t\tvalues = newValues;\n\t\t\t\tif (deferred.length)\n\t\t\t\t\tdefer(function() {\n\t\t\t\t\t\tfor (var i = 0; i < deferred.length; i++)\n\t\t\t\t\t\t\tdeferred[i]();\n\t\t\t\t\t});\n\t\t\t}\n\t\t\treturn state;\n\t\t};\n\n\t\tset['then'] = function (onFulfilled, onRejected) {\n\t\t\tvar promise2 = pinkySwear(extend);\n\t\t\tvar callCallbacks = function() {\n\t    \t\ttry {\n\t    \t\t\tvar f = (state ? onFulfilled : onRejected);\n\t    \t\t\tif (isFunction(f)) {\n\t\t   \t\t\t\tfunction resolve(x) {\n\t\t\t\t\t\t    var then, cbCalled = 0;\n\t\t   \t\t\t\t\ttry {\n\t\t\t\t   \t\t\t\tif (x && (isObject(x) || isFunction(x)) && isFunction(then = x['then'])) {\n\t\t\t\t\t\t\t\t\t\tif (x === promise2)\n\t\t\t\t\t\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t\t\t\t\t\tthen['call'](x,\n\t\t\t\t\t\t\t\t\t\t\tfunction() { if (!cbCalled++) resolve.apply(undef,arguments); } ,\n\t\t\t\t\t\t\t\t\t\t\tfunction(value){ if (!cbCalled++) promise2(false,[value]);});\n\t\t\t\t   \t\t\t\t}\n\t\t\t\t   \t\t\t\telse\n\t\t\t\t   \t\t\t\t\tpromise2(true, arguments);\n\t\t   \t\t\t\t\t}\n\t\t   \t\t\t\t\tcatch(e) {\n\t\t   \t\t\t\t\t\tif (!cbCalled++)\n\t\t   \t\t\t\t\t\t\tpromise2(false, [e]);\n\t\t   \t\t\t\t\t}\n\t\t   \t\t\t\t}\n\t\t   \t\t\t\tresolve(f.apply(undef, values || []));\n\t\t   \t\t\t}\n\t\t   \t\t\telse\n\t\t   \t\t\t\tpromise2(state, values);\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tpromise2(false, [e]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (state != null)\n\t\t\t\tdefer(callCallbacks);\n\t\t\telse\n\t\t\t\tdeferred.push(callCallbacks);\n\t\t\treturn promise2;\n\t\t};\n        if(extend){\n            set = extend(set);\n        }\n\t\treturn set;\n\t};\n})(typeof module == 'undefined' ? [window, 'pinkySwear'] : [module, 'exports']);\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pinkyswear/pinkyswear.js\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 4\n ** module chunks = 0\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/timers-browserify/main.js\n ** module id = 5\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * @preserve jquery-param (c) 2015 KNOWLEDGECODE | MIT\n */\n/*global define */\n(function (global) {\n    'use strict';\n\n    var param = function (a) {\n        var add = function (s, k, v) {\n            v = typeof v === 'function' ? v() : v === null ? '' : v === undefined ? '' : v;\n            s[s.length] = encodeURIComponent(k) + '=' + encodeURIComponent(v);\n        }, buildParams = function (prefix, obj, s) {\n            var i, len, key;\n\n            if (Object.prototype.toString.call(obj) === '[object Array]') {\n                for (i = 0, len = obj.length; i < len; i++) {\n                    buildParams(prefix + '[' + (typeof obj[i] === 'object' ? i : '') + ']', obj[i], s);\n                }\n            } else if (obj && obj.toString() === '[object Object]') {\n                for (key in obj) {\n                    if (obj.hasOwnProperty(key)) {\n                        if (prefix) {\n                            buildParams(prefix + '[' + key + ']', obj[key], s, add);\n                        } else {\n                            buildParams(key, obj[key], s, add);\n                        }\n                    }\n                }\n            } else if (prefix) {\n                add(s, prefix, obj);\n            } else {\n                for (key in obj) {\n                    add(s, key, obj[key]);\n                }\n            }\n            return s;\n        };\n        return buildParams('', a, []).join('&').replace(/%20/g, '+');\n    };\n\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        module.exports = param;\n    } else if (typeof define === 'function' && define.amd) {\n        define([], function () {\n            return param;\n        });\n    } else {\n        global.param = param;\n    }\n\n}(this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jquery-param/jquery-param.js\n ** module id = 7\n ** module chunks = 0\n **/","/* global WebSocket */\nvar EventEmitter = require('eventemitter2').EventEmitter2\nvar Q = require('q')\n\nvar Webmo = function Webmo (host) {\n  host = host || 'webmo.local'\n\n  this.host = host\n  this.stepDegree = 1.8\n  this.onmessage = null\n  this._ws = new WebSocket('ws://' + host + ':8080/')\n  this._ev = new EventEmitter()\n\n  this._ws.onopen = function (e) {\n    if (typeof (this.onopen) === 'function') {\n      this.onopen(e)\n    }\n    this._ev.emit('open')\n  }.bind(this)\n\n  this._ws.onmessage = function (e) {\n    var json = JSON.parse(e.data)\n\n    if (typeof (this.onmessage) === 'function') {\n      this.onmessage(json)\n    }\n    this._ev.emit(json.type, json)\n  }.bind(this)\n\n  this._ws.onclose = function (e) {\n    if (typeof (this.onclose) === 'function') {\n      this.onclose()\n    }\n\n    console.log('closed', e)\n  }.bind(this)\n\n  this._ws.onerror = function (e) {\n    if (typeof (this.onerror) === 'function') {\n      this.onerror()\n    }\n    console.log('error!', e)\n  }.bind(this)\n}\n\nWebmo.prototype.getStatus = function getStatus () {\n  var packed = JSON.stringify({type: 'status'})\n  this._ws.send(packed)\n}\n\n//\n// rotate\n//\nWebmo.prototype.rotate = function rotate (speed, option) {\n  if (typeof speed === 'object') {\n    option = speed\n    speed = undefined\n  }\n\n  var packed = JSON.stringify({type: 'rotate', speed: speed})\n  this._ws.send(packed)\n}\n\nWebmo.prototype.rotateTo = function rotateTo (target, absRange, speed) {\n  var packed = JSON.stringify({type: 'rotateTo', target: target, absRange: absRange, speed: speed})\n  this._ws.send(packed)\n\n  // XXX: reject\n  return Q.Promise(function (resolve, reject) {\n    this._ev.on('notice', function (data) {\n      if (data.msg === 'done' && data.func === 'rotateTo') {\n        resolve(data)\n      }\n    })\n  }.bind(this))\n}\n\nWebmo.prototype.rotateBy = function rotateBy (diff, speed) {\n  var packed = JSON.stringify({type: 'rotateBy', diff: diff, speed: speed})\n  this._ws.send(packed)\n\n  // XXX: reject\n  return Q.Promise(function (resolve, reject) {\n    this._ev.on('notice', function (data) {\n      if (data.msg === 'done' && data.func === 'rotateBy') {\n        resolve(data)\n      }\n    })\n  }.bind(this))\n}\n\nWebmo.prototype.rotateToHome = function rotateToHome () {\n  console.log('not impl')\n}\n\n//\n// Stop\n//\nWebmo.prototype.stopHard = function stopHard () {\n  return this.stop(true, false)\n}\n\nWebmo.prototype.stopSoft = function stopSoft () {\n  return this.stop(false, false)\n}\n\nWebmo.prototype.stop = function stop (smooth, lock) {\n  var packed = JSON.stringify({type: 'stop', smooth: smooth, lock: lock})\n  this._ws.send(packed)\n\n  // XXX: reject\n  return Q.Promise(function (resolve, reject) {\n    this._ev.on('notice', function (data) {\n      if (data.msg === 'done' && data.func === 'stop') {\n        resolve(data)\n      }\n    })\n  }.bind(this))\n}\n//\n// lock\n//\nWebmo.prototype.lock = function lock (smooth) {\n  var packed = JSON.stringify({type: 'lock', smooth: smooth})\n  this._ws.send(packed)\n}\n\nWebmo.prototype.unlock = function unlock () {\n  var packed = JSON.stringify({type: 'unlock'})\n  this._ws.send(packed)\n}\n\n//\n// goodies\n//\nWebmo.prototype.tick = function tick (timeMs) {\n  var packed = JSON.stringify({type: 'tick', timeMs: timeMs})\n  this._ws.send(packed)\n}\n\n//\n// Home\n//\nWebmo.prototype.resetHome = function resetHome () {\n  console.log('not impl')\n}\n\n// helper function\nWebmo.prototype.degreeToStep = function degreeToStep (degree) {\n  return degree / this.stepDegree\n}\n\nWebmo.prototype.stepToDegree = function stepToDegree (step) {\n  return step * this.stepDegree / 128 // XXX: microstep must be supplied\n}\n\nWebmo.prototype.getSpeedPerSecondByStep = function getSpeedPerSecondByStep (step) {\n  return Math.pow(2, 28) * step / Math.pow(10, 9) * 250\n}\n\nWebmo.prototype.getSpeedPerSecondByDegree = function getSpeedPerSecondByDegree (degree) {\n  return this.getSpeedPerSecondByStep(this.degreeToStep(degree))\n}\n\nmodule.exports = Webmo\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/ws.js\n ** module id = 8\n ** module chunks = 0\n **/","/*!\r\n * EventEmitter2\r\n * https://github.com/hij1nx/EventEmitter2\r\n *\r\n * Copyright (c) 2013 hij1nx\r\n * Licensed under the MIT license.\r\n */\r\n;!function(undefined) {\r\n\r\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\r\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\r\n  };\r\n  var defaultMaxListeners = 10;\r\n\r\n  function init() {\r\n    this._events = {};\r\n    if (this._conf) {\r\n      configure.call(this, this._conf);\r\n    }\r\n  }\r\n\r\n  function configure(conf) {\r\n    if (conf) {\r\n\r\n      this._conf = conf;\r\n\r\n      conf.delimiter && (this.delimiter = conf.delimiter);\r\n      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\r\n      conf.wildcard && (this.wildcard = conf.wildcard);\r\n      conf.newListener && (this.newListener = conf.newListener);\r\n\r\n      if (this.wildcard) {\r\n        this.listenerTree = {};\r\n      }\r\n    }\r\n  }\r\n\r\n  function EventEmitter(conf) {\r\n    this._events = {};\r\n    this.newListener = false;\r\n    configure.call(this, conf);\r\n  }\r\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\r\n\r\n  //\r\n  // Attention, function return type now is array, always !\r\n  // It has zero elements if no any matches found and one or more\r\n  // elements (leafs) if there are matches\r\n  //\r\n  function searchListenerTree(handlers, type, tree, i) {\r\n    if (!tree) {\r\n      return [];\r\n    }\r\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\r\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\r\n    if (i === typeLength && tree._listeners) {\r\n      //\r\n      // If at the end of the event(s) list and the tree has listeners\r\n      // invoke those listeners.\r\n      //\r\n      if (typeof tree._listeners === 'function') {\r\n        handlers && handlers.push(tree._listeners);\r\n        return [tree];\r\n      } else {\r\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\r\n          handlers && handlers.push(tree._listeners[leaf]);\r\n        }\r\n        return [tree];\r\n      }\r\n    }\r\n\r\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\r\n      //\r\n      // If the event emitted is '*' at this part\r\n      // or there is a concrete match at this patch\r\n      //\r\n      if (currentType === '*') {\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\r\n          }\r\n        }\r\n        return listeners;\r\n      } else if(currentType === '**') {\r\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\r\n        if(endReached && tree._listeners) {\r\n          // The next element has a _listeners, add it to the handlers.\r\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\r\n        }\r\n\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            if(branch === '*' || branch === '**') {\r\n              if(tree[branch]._listeners && !endReached) {\r\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\r\n              }\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            } else if(branch === nextType) {\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\r\n            } else {\r\n              // No match on this one, shift into the tree but not in the type array.\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            }\r\n          }\r\n        }\r\n        return listeners;\r\n      }\r\n\r\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\r\n    }\r\n\r\n    xTree = tree['*'];\r\n    if (xTree) {\r\n      //\r\n      // If the listener tree will allow any match for this part,\r\n      // then recursively explore all branches of the tree\r\n      //\r\n      searchListenerTree(handlers, type, xTree, i+1);\r\n    }\r\n\r\n    xxTree = tree['**'];\r\n    if(xxTree) {\r\n      if(i < typeLength) {\r\n        if(xxTree._listeners) {\r\n          // If we have a listener on a '**', it will catch all, so add its handler.\r\n          searchListenerTree(handlers, type, xxTree, typeLength);\r\n        }\r\n\r\n        // Build arrays of matching next branches and others.\r\n        for(branch in xxTree) {\r\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\r\n            if(branch === nextType) {\r\n              // We know the next element will match, so jump twice.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\r\n            } else if(branch === currentType) {\r\n              // Current node matches, move into the tree.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\r\n            } else {\r\n              isolatedBranch = {};\r\n              isolatedBranch[branch] = xxTree[branch];\r\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\r\n            }\r\n          }\r\n        }\r\n      } else if(xxTree._listeners) {\r\n        // We have reached the end and still on a '**'\r\n        searchListenerTree(handlers, type, xxTree, typeLength);\r\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\r\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\r\n      }\r\n    }\r\n\r\n    return listeners;\r\n  }\r\n\r\n  function growListenerTree(type, listener) {\r\n\r\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\r\n    //\r\n    // Looks for two consecutive '**', if so, don't add the event at all.\r\n    //\r\n    for(var i = 0, len = type.length; i+1 < len; i++) {\r\n      if(type[i] === '**' && type[i+1] === '**') {\r\n        return;\r\n      }\r\n    }\r\n\r\n    var tree = this.listenerTree;\r\n    var name = type.shift();\r\n\r\n    while (name) {\r\n\r\n      if (!tree[name]) {\r\n        tree[name] = {};\r\n      }\r\n\r\n      tree = tree[name];\r\n\r\n      if (type.length === 0) {\r\n\r\n        if (!tree._listeners) {\r\n          tree._listeners = listener;\r\n        }\r\n        else if(typeof tree._listeners === 'function') {\r\n          tree._listeners = [tree._listeners, listener];\r\n        }\r\n        else if (isArray(tree._listeners)) {\r\n\r\n          tree._listeners.push(listener);\r\n\r\n          if (!tree._listeners.warned) {\r\n\r\n            var m = defaultMaxListeners;\r\n\r\n            if (typeof this._events.maxListeners !== 'undefined') {\r\n              m = this._events.maxListeners;\r\n            }\r\n\r\n            if (m > 0 && tree._listeners.length > m) {\r\n\r\n              tree._listeners.warned = true;\r\n              console.error('(node) warning: possible EventEmitter memory ' +\r\n                            'leak detected. %d listeners added. ' +\r\n                            'Use emitter.setMaxListeners() to increase limit.',\r\n                            tree._listeners.length);\r\n              if(console.trace){\r\n                console.trace();\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      name = type.shift();\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // By default EventEmitters will print a warning if more than\r\n  // 10 listeners are added to it. This is a useful default which\r\n  // helps finding memory leaks.\r\n  //\r\n  // Obviously not all Emitters should be limited to 10. This function allows\r\n  // that to be increased. Set to zero for unlimited.\r\n\r\n  EventEmitter.prototype.delimiter = '.';\r\n\r\n  EventEmitter.prototype.setMaxListeners = function(n) {\r\n    this._events || init.call(this);\r\n    this._events.maxListeners = n;\r\n    if (!this._conf) this._conf = {};\r\n    this._conf.maxListeners = n;\r\n  };\r\n\r\n  EventEmitter.prototype.event = '';\r\n\r\n  EventEmitter.prototype.once = function(event, fn) {\r\n    this.many(event, 1, fn);\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.many = function(event, ttl, fn) {\r\n    var self = this;\r\n\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('many only accepts instances of Function');\r\n    }\r\n\r\n    function listener() {\r\n      if (--ttl === 0) {\r\n        self.off(event, listener);\r\n      }\r\n      fn.apply(this, arguments);\r\n    }\r\n\r\n    listener._origin = fn;\r\n\r\n    this.on(event, listener);\r\n\r\n    return self;\r\n  };\r\n\r\n  EventEmitter.prototype.emit = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n      if (!this._events.newListener) { return false; }\r\n    }\r\n\r\n    // Loop through the *_all* functions and invoke them.\r\n    if (this._all) {\r\n      var l = arguments.length;\r\n      var args = new Array(l - 1);\r\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n      for (i = 0, l = this._all.length; i < l; i++) {\r\n        this.event = type;\r\n        this._all[i].apply(this, [type].concat(args));\r\n      }\r\n    }\r\n\r\n    // If there is no 'error' event listener then throw.\r\n    if (type === 'error') {\r\n\r\n      if (!this._all &&\r\n        !this._events.error &&\r\n        !(this.wildcard && this.listenerTree.error)) {\r\n\r\n        if (arguments[1] instanceof Error) {\r\n          throw arguments[1]; // Unhandled 'error' event\r\n        } else {\r\n          throw new Error(\"Uncaught, unspecified 'error' event.\");\r\n        }\r\n        return false;\r\n      }\r\n    }\r\n\r\n    var handler;\r\n\r\n    if(this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    }\r\n    else {\r\n      handler = this._events[type];\r\n    }\r\n\r\n    if (typeof handler === 'function') {\r\n      this.event = type;\r\n      if (arguments.length === 1) {\r\n        handler.call(this);\r\n      }\r\n      else if (arguments.length > 1)\r\n        switch (arguments.length) {\r\n          case 2:\r\n            handler.call(this, arguments[1]);\r\n            break;\r\n          case 3:\r\n            handler.call(this, arguments[1], arguments[2]);\r\n            break;\r\n          // slower\r\n          default:\r\n            var l = arguments.length;\r\n            var args = new Array(l - 1);\r\n            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n            handler.apply(this, args);\r\n        }\r\n      return true;\r\n    }\r\n    else if (handler) {\r\n      var l = arguments.length;\r\n      var args = new Array(l - 1);\r\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n\r\n      var listeners = handler.slice();\r\n      for (var i = 0, l = listeners.length; i < l; i++) {\r\n        this.event = type;\r\n        listeners[i].apply(this, args);\r\n      }\r\n      return (listeners.length > 0) || !!this._all;\r\n    }\r\n    else {\r\n      return !!this._all;\r\n    }\r\n\r\n  };\r\n\r\n  EventEmitter.prototype.emitAsync = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n      if (!this._events.newListener) { return Promise.resolve([false]); }\r\n    }\r\n\r\n    var promises= [];\r\n\r\n    // Loop through the *_all* functions and invoke them.\r\n    if (this._all) {\r\n      var l = arguments.length;\r\n      var args = new Array(l - 1);\r\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n      for (i = 0, l = this._all.length; i < l; i++) {\r\n        this.event = type;\r\n        promises.push(this._all[i].apply(this, args));\r\n      }\r\n    }\r\n\r\n    // If there is no 'error' event listener then throw.\r\n    if (type === 'error') {\r\n\r\n      if (!this._all &&\r\n        !this._events.error &&\r\n        !(this.wildcard && this.listenerTree.error)) {\r\n\r\n        if (arguments[1] instanceof Error) {\r\n          return Promise.reject(arguments[1]); // Unhandled 'error' event\r\n        } else {\r\n          return Promise.reject(\"Uncaught, unspecified 'error' event.\");\r\n        }\r\n      }\r\n    }\r\n\r\n    var handler;\r\n\r\n    if(this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    }\r\n    else {\r\n      handler = this._events[type];\r\n    }\r\n\r\n    if (typeof handler === 'function') {\r\n      this.event = type;\r\n      if (arguments.length === 1) {\r\n        promises.push(handler.call(this));\r\n      }\r\n      else if (arguments.length > 1) {\r\n        switch (arguments.length) {\r\n          case 2:\r\n            promises.push(handler.call(this, arguments[1]));\r\n            break;\r\n          case 3:\r\n            promises.push(handler.call(this, arguments[1], arguments[2]));\r\n            break;\r\n          // slower\r\n          default:\r\n            var l = arguments.length;\r\n            var args = new Array(l - 1);\r\n            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n            promises.push(handler.apply(this, args));\r\n        }\r\n      }\r\n    }\r\n    else if (handler) {\r\n      var l = arguments.length;\r\n      var args = new Array(l - 1);\r\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\r\n\r\n      var listeners = handler.slice();\r\n      for (var i = 0, l = listeners.length; i < l; i++) {\r\n        this.event = type;\r\n        promises.push(listeners[i].apply(this, args));\r\n      }\r\n    }\r\n    return Promise.all(promises);\r\n  };\r\n\r\n  EventEmitter.prototype.on = function(type, listener) {\r\n\r\n    if (typeof type === 'function') {\r\n      this.onAny(type);\r\n      return this;\r\n    }\r\n\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('on only accepts instances of Function');\r\n    }\r\n    this._events || init.call(this);\r\n\r\n    // To avoid recursion in the case that type == \"newListeners\"! Before\r\n    // adding it to the listeners, first emit \"newListeners\".\r\n    this.emit('newListener', type, listener);\r\n\r\n    if(this.wildcard) {\r\n      growListenerTree.call(this, type, listener);\r\n      return this;\r\n    }\r\n\r\n    if (!this._events[type]) {\r\n      // Optimize the case of one listener. Don't need the extra array object.\r\n      this._events[type] = listener;\r\n    }\r\n    else if(typeof this._events[type] === 'function') {\r\n      // Adding the second element, need to change to array.\r\n      this._events[type] = [this._events[type], listener];\r\n    }\r\n    else if (isArray(this._events[type])) {\r\n      // If we've already got an array, just append.\r\n      this._events[type].push(listener);\r\n\r\n      // Check for listener leak\r\n      if (!this._events[type].warned) {\r\n\r\n        var m = defaultMaxListeners;\r\n\r\n        if (typeof this._events.maxListeners !== 'undefined') {\r\n          m = this._events.maxListeners;\r\n        }\r\n\r\n        if (m > 0 && this._events[type].length > m) {\r\n\r\n          this._events[type].warned = true;\r\n          console.error('(node) warning: possible EventEmitter memory ' +\r\n                        'leak detected. %d listeners added. ' +\r\n                        'Use emitter.setMaxListeners() to increase limit.',\r\n                        this._events[type].length);\r\n          if(console.trace){\r\n            console.trace();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.onAny = function(fn) {\r\n\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('onAny only accepts instances of Function');\r\n    }\r\n\r\n    if(!this._all) {\r\n      this._all = [];\r\n    }\r\n\r\n    // Add the function to the event listener collection.\r\n    this._all.push(fn);\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n  EventEmitter.prototype.off = function(type, listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('removeListener only takes instances of Function');\r\n    }\r\n\r\n    var handlers,leafs=[];\r\n\r\n    if(this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n    }\r\n    else {\r\n      // does not use listeners(), so no side effect of creating _events[type]\r\n      if (!this._events[type]) return this;\r\n      handlers = this._events[type];\r\n      leafs.push({_listeners:handlers});\r\n    }\r\n\r\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n      var leaf = leafs[iLeaf];\r\n      handlers = leaf._listeners;\r\n      if (isArray(handlers)) {\r\n\r\n        var position = -1;\r\n\r\n        for (var i = 0, length = handlers.length; i < length; i++) {\r\n          if (handlers[i] === listener ||\r\n            (handlers[i].listener && handlers[i].listener === listener) ||\r\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\r\n            position = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (position < 0) {\r\n          continue;\r\n        }\r\n\r\n        if(this.wildcard) {\r\n          leaf._listeners.splice(position, 1);\r\n        }\r\n        else {\r\n          this._events[type].splice(position, 1);\r\n        }\r\n\r\n        if (handlers.length === 0) {\r\n          if(this.wildcard) {\r\n            delete leaf._listeners;\r\n          }\r\n          else {\r\n            delete this._events[type];\r\n          }\r\n        }\r\n        \r\n        this.emit(\"removeListener\", type, listener);\r\n        \r\n        return this;\r\n      }\r\n      else if (handlers === listener ||\r\n        (handlers.listener && handlers.listener === listener) ||\r\n        (handlers._origin && handlers._origin === listener)) {\r\n        if(this.wildcard) {\r\n          delete leaf._listeners;\r\n        }\r\n        else {\r\n          delete this._events[type];\r\n        }\r\n        \r\n        this.emit(\"removeListener\", type, listener);\r\n      }\r\n    }\r\n\r\n    function recursivelyGarbageCollect(root) {\r\n      if (root === undefined) {\r\n        return;\r\n      }\r\n      var keys = Object.keys(root);\r\n      for (var i in keys) {\r\n        var key = keys[i];\r\n        var obj = root[key];\r\n        if ((obj instanceof Function) || (typeof obj !== \"object\"))\r\n          continue;\r\n        if (Object.keys(obj).length > 0) {\r\n          recursivelyGarbageCollect(root[key]);\r\n        }\r\n        if (Object.keys(obj).length === 0) {\r\n          delete root[key];\r\n        }\r\n      }\r\n    }\r\n    recursivelyGarbageCollect(this.listenerTree);\r\n\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.offAny = function(fn) {\r\n    var i = 0, l = 0, fns;\r\n    if (fn && this._all && this._all.length > 0) {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++) {\r\n        if(fn === fns[i]) {\r\n          fns.splice(i, 1);\r\n          this.emit(\"removeListenerAny\", fn);\r\n          return this;\r\n        }\r\n      }\r\n    } else {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++)\r\n        this.emit(\"removeListenerAny\", fns[i]);\r\n      this._all = [];\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\r\n\r\n  EventEmitter.prototype.removeAllListeners = function(type) {\r\n    if (arguments.length === 0) {\r\n      !this._events || init.call(this);\r\n      return this;\r\n    }\r\n\r\n    if(this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n\r\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n        var leaf = leafs[iLeaf];\r\n        leaf._listeners = null;\r\n      }\r\n    }\r\n    else {\r\n      if (!this._events || !this._events[type]) return this;\r\n      this._events[type] = null;\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.listeners = function(type) {\r\n    if(this.wildcard) {\r\n      var handlers = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\r\n      return handlers;\r\n    }\r\n\r\n    this._events || init.call(this);\r\n\r\n    if (!this._events[type]) this._events[type] = [];\r\n    if (!isArray(this._events[type])) {\r\n      this._events[type] = [this._events[type]];\r\n    }\r\n    return this._events[type];\r\n  };\r\n\r\n  EventEmitter.prototype.listenersAny = function() {\r\n\r\n    if(this._all) {\r\n      return this._all;\r\n    }\r\n    else {\r\n      return [];\r\n    }\r\n\r\n  };\r\n\r\n  if (typeof define === 'function' && define.amd) {\r\n     // AMD. Register as an anonymous module.\r\n    define(function() {\r\n      return EventEmitter;\r\n    });\r\n  } else if (typeof exports === 'object') {\r\n    // CommonJS\r\n    module.exports = EventEmitter;\r\n  }\r\n  else {\r\n    // Browser global.\r\n    window.EventEmitter2 = EventEmitter;\r\n  }\r\n}();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/eventemitter2/lib/eventemitter2.js\n ** module id = 9\n ** module chunks = 0\n **/","// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2012 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    \"use strict\";\n\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n\n    // CommonJS\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\n        module.exports = definition();\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define(definition);\n\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== \"undefined\") {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeQ = definition;\n        }\n\n    // <script>\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n        // Prefer window over self for add-on scripts. Use self for\n        // non-windowed contexts.\n        var global = typeof window !== \"undefined\" ? window : self;\n\n        // Get the `window` object, save the previous Q global\n        // and initialize Q as a global.\n        var previousQ = global.Q;\n        global.Q = definition();\n\n        // Add a noConflict function so Q can be removed from the\n        // global namespace.\n        global.Q.noConflict = function () {\n            global.Q = previousQ;\n            return this;\n        };\n\n    } else {\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n    }\n\n})(function () {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = [];\n\n    function flush() {\n        /* jshint loopfunc: true */\n        var task, domain;\n\n        while (head.next) {\n            head = head.next;\n            task = head.task;\n            head.task = void 0;\n            domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n            runSingle(task, domain);\n\n        }\n        while (laterQueue.length) {\n            task = laterQueue.pop();\n            runSingle(task);\n        }\n        flushing = false;\n    }\n    // runs a single function in the async queue\n    function runSingle(task, domain) {\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process === \"object\" &&\n        process.toString() === \"[object process]\" && process.nextTick) {\n        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n        // To see through fake Node environments:\n        // * Mocha test runner - exposes a `process` global without a `nextTick`\n        // * Browserify - exposes a `process.nexTick` function that uses\n        //   `setTimeout`. In this case `setImmediate` is preferred because\n        //    it is faster. Browserify's `process.toString()` yields\n        //   \"[object Object]\", while in a real Node environment\n        //   `process.nextTick()` yields \"[object process]\".\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    nextTick.runAfter = function (task) {\n        laterQueue.push(task);\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you dont need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Millers explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack &&\n        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack) {\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        error.stack = filterStackString(concatedStacks);\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n// enable long stacks if Q_DEBUG is set\nif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            Q.nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n        promise.source = newPromise;\n\n        array_reduce(messages, function (undefined, message) {\n            Q.nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            Q.nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.Promise = promise; // ES6\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\npromise.race = race; // ES6\npromise.all = all; // ES6\npromise.reject = reject; // ES6\npromise.resolve = Q; // ES6\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function (resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function (answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    Q.nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\nQ.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n};\n\n/**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */\nPromise.prototype.tap = function (callback) {\n    callback = Q(callback);\n\n    return this.then(function (value) {\n        return callback.fcall(value).thenResolve(value);\n    });\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If its a fulfilled promise, the fulfillment value is nearer.\n * If its a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object instanceof Promise;\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar reportedUnhandledRejections = [];\nvar trackUnhandledRejections = true;\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n        Q.nextTick.runAfter(function () {\n            if (array_indexOf(unhandledRejections, promise) !== -1) {\n                process.emit(\"unhandledRejection\", reason, promise);\n                reportedUnhandledRejections.push(promise);\n            }\n        });\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function () {\n                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                if (atReport !== -1) {\n                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                    reportedUnhandledRejections.splice(atReport, 1);\n                }\n            });\n        }\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n\n            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n            // engine that has a deployed base of browsers that support generators.\n            // However, SM's generators use the Python-inspired semantics of\n            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n            // like to make it possible to use generators in deployed browsers, so\n            // we also support Python-style generators.  At some point we can remove\n            // this block.\n\n            if (typeof StopIteration === \"undefined\") {\n                // ES6 Generators\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return Q(result.value);\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // SpiderMonkey Generators\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return Q(exception.value);\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var pendingCount = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++pendingCount;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (pendingCount === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */\nQ.any = any;\n\nfunction any(promises) {\n    if (promises.length === 0) {\n        return Q.resolve();\n    }\n\n    var deferred = Q.defer();\n    var pendingCount = 0;\n    array_reduce(promises, function (prev, current, index) {\n        var promise = promises[index];\n\n        pendingCount++;\n\n        when(promise, onFulfilled, onRejected, onProgress);\n        function onFulfilled(result) {\n            deferred.resolve(result);\n        }\n        function onRejected() {\n            pendingCount--;\n            if (pendingCount === 0) {\n                deferred.reject(new Error(\n                    \"Can't get fulfillment value from any promise, all \" +\n                    \"promises were rejected.\"\n                ));\n            }\n        }\n        function onProgress(progress) {\n            deferred.notify({\n                index: index,\n                value: progress\n            });\n        }\n    }, undefined);\n\n    return deferred.promise;\n}\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        Q.nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n};\n\nPromise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        if (!error || \"string\" === typeof error) {\n            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n            error.code = \"ETIMEDOUT\";\n        }\n        deferred.reject(error);\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            Q.nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            Q.nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\nQ.noConflict = function() {\n    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/q/q.js\n ** module id = 10\n ** module chunks = 0\n **/"],"sourceRoot":""}